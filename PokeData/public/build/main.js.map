{"version":3,"file":"main.js","sources":["../../node_modules/.pnpm/svelte@3.38.3/node_modules/svelte/internal/index.mjs","../../src/data/apiConfig.js","../../src/corsProxy.js","../../src/services/storage/db.js","../../src/services/pokeDataService.js","../../src/components/SearchableSelect.svelte","../../src/components/CardSearchSelect.svelte","../../src/components/CardVariantSelector.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached\n    const children = target.childNodes;\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        const seqLen = upper_bound(1, longest + 1, idx => children[m[idx]].claim_order, current) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        if (node !== target.actual_end_child) {\n            target.insertBefore(node, target.actual_end_child);\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append(target, node);\n    }\n    else if (node.parentNode !== target || (anchor && node.nextSibling !== anchor)) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                processNode(node);\n                nodes.splice(i, 1);\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                processNode(node);\n                nodes.splice(i, 1);\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n    }, () => svg ? svg_element(name) : element(name));\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        node.data = '' + data;\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTag();\n    }\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    return new HtmlTag(html_tag_nodes.slice(1, html_tag_nodes.length - 1));\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(claimed_nodes) {\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            if (this.l) {\n                this.n = this.l;\n            }\n            else {\n                this.h(html);\n            }\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.3' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_await_block_branch, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","// API Configuration\nexport const API_CONFIG = {\n  // Base URL for the API\n  baseUrl: 'https://maber-apim-test.azure-api.net/pokedata-api/v0',\n  \n  // API key for authentication\n  apiKey: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTczNzMxNzE0MiwianRpIjoiNjJkNWU1ZjktNTI5ZC00NGIyLTlkMTgtOTY3NWQ3ZTU3NWMwIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjJlZGY1N2Y2LWU5OTYtNGNhMy1iZDk5LTFlZDY3MDRkMzJhOSIsIm5iZiI6MTczNzMxNzE0MiwidG9rZW5fdHlwZSI6ImFwaSJ9.y4JduoyU_gG1aiBy4w6frD3h3m-AEoxw_7f6vExYay4',\n  \n  // Subscription key for API Management\n  subscriptionKey: '1c3e73f4352b415c98eb89f91541c4e4',\n  \n  // Endpoints\n  endpoints: {\n    pricing: '/pricing', // Get Info and Pricing for Card or Product\n    sets: '/sets',      // List All Sets \n    set: '/set'         // List Cards in Set\n  },\n  \n  // Headers function to get standard headers\n  getHeaders() {\n    return {\n      //'Authorization': `Bearer ${this.apiKey}`,\n      //'Ocp-Apim-Subscription-Key': this.subscriptionKey,\n      'Content-Type': 'application/json'\n    };\n  },\n  \n  // URL builder functions\n  buildPricingUrl(id) {\n    return `${this.baseUrl}${this.endpoints.pricing}?id=${encodeURIComponent(id)}&asset_type=CARD`;\n  },\n  \n  buildSetsUrl() {\n    return `${this.baseUrl}${this.endpoints.sets}`;\n  },\n  \n  buildCardsForSetUrl(setId) {\n    return `${this.baseUrl}${this.endpoints.set}?set_id=${encodeURIComponent(setId)}`;\n  }\n};","// Simple direct fetch - relies on your API Management service to handle CORS\nexport async function fetchWithProxy(url, options = {}) {\n  // Just use the standard fetch with the provided options\n  try {\n    console.log(`Fetching from: ${url}`);\n    console.log('Using headers:', options.headers);\n    \n    const response = await fetch(url, {\n      ...options,\n      mode: 'cors', // Use CORS mode to allow cross-origin requests\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unable to get error details');\n      console.error(`HTTP Error: ${response.status} - ${response.statusText}\\nURL: ${url}\\nDetails: ${errorText}`);\n      throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error(`Fetch error for URL [${url}]:`, error);\n    throw error;\n  }\n}","/**\n * IndexedDB Storage Service\n * Provides persistent storage for set list and card data\n */\n\n// Database configuration\nconst DB_NAME = 'poke-data-db';\nconst DB_VERSION = 1; // Reset to version 1\nconst STORES = {\n  setList: 'setList',\n  cardsBySet: 'cardsBySet',\n  cardPricing: 'cardPricing' // Added store for card pricing\n};\n\n/**\n * Open the IndexedDB database\n * @returns {Promise<IDBDatabase>} The database instance\n */\nexport const openDatabase = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error opening database:', event.target.error);\n      reject(event.target.error);\n    };\n    \n    request.onsuccess = (event) => {\n      resolve(event.target.result);\n    };\n    \n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      \n      // Create stores if they don't exist\n      if (!db.objectStoreNames.contains(STORES.setList)) {\n        db.createObjectStore(STORES.setList, { keyPath: 'id' });\n      }\n      \n      if (!db.objectStoreNames.contains(STORES.cardsBySet)) {\n        db.createObjectStore(STORES.cardsBySet, { keyPath: 'setCode' });\n      }\n      \n      // Create cardPricing store if it doesn't exist\n      if (!db.objectStoreNames.contains(STORES.cardPricing)) {\n        db.createObjectStore(STORES.cardPricing, { keyPath: 'id' });\n      }\n    };\n  });\n};\n\n/**\n * Database Service for managing persistent storage of card data\n */\nexport const dbService = {\n  /**\n   * Save the set list to IndexedDB\n   * @param {Array} setList - The array of set objects\n   * @returns {Promise<void>}\n   */\n  async saveSetList(setList) {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.setList, 'readwrite');\n      const store = transaction.objectStore(STORES.setList);\n      \n      // We'll store the entire set list as a single record\n      await store.put({\n        id: 'pokemonSets',\n        data: setList,\n        timestamp: Date.now()\n      });\n      \n      return new Promise((resolve, reject) => {\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error('Error saving set list:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get the set list from IndexedDB\n   * @returns {Promise<Array>} The array of set objects\n   */\n  async getSetList() {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.setList, 'readonly');\n      const store = transaction.objectStore(STORES.setList);\n      \n      const request = store.get('pokemonSets');\n      \n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          // If we have the data in the cache, return it\n          if (request.result && request.result.data) {\n            resolve(request.result.data);\n          } else {\n            // No data found\n            resolve(null);\n          }\n        };\n        \n        request.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error('Error getting set list:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Save cards for a specific set to IndexedDB\n   * @param {string} setCode - The set code\n   * @param {Array} cards - The array of card objects for the set\n   * @returns {Promise<void>}\n   */\n  async saveCardsForSet(setCode, cards) {\n    try {\n      // Use a fallback key if setCode is null or undefined\n      const storageKey = setCode || 'unknown-set';\n      \n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardsBySet, 'readwrite');\n      const store = transaction.objectStore(STORES.cardsBySet);\n      \n      await store.put({\n        setCode: storageKey,\n        cards,\n        timestamp: Date.now()\n      });\n      \n      return new Promise((resolve, reject) => {\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error saving cards for set ${setCode}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get cards for a specific set from IndexedDB\n   * @param {string} setCode - The set code\n   * @returns {Promise<Array>} The array of card objects for the set\n   */\n  async getCardsForSet(setCode) {\n    try {\n      // Use a fallback key if setCode is null or undefined\n      const storageKey = setCode || 'unknown-set';\n      \n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardsBySet, 'readonly');\n      const store = transaction.objectStore(STORES.cardsBySet);\n      \n      const request = store.get(storageKey);\n      \n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          // If we have the data in the cache, return it\n          if (request.result && request.result.cards) {\n            resolve(request.result.cards);\n          } else {\n            // No data found\n            resolve(null);\n          }\n        };\n        \n        request.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error getting cards for set ${setCode}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Save pricing data for a specific card to IndexedDB\n   * @param {string} cardId - The card ID\n   * @param {Object} pricingData - The pricing data for the card\n   * @returns {Promise<void>}\n   */\n  async saveCardPricing(cardId, pricingData) {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardPricing, 'readwrite');\n      const store = transaction.objectStore(STORES.cardPricing);\n      \n      await store.put({\n        id: cardId,\n        data: pricingData,\n        timestamp: Date.now()\n      });\n      \n      return new Promise((resolve, reject) => {\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error saving pricing data for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get pricing data for a specific card from IndexedDB\n   * @param {string} cardId - The card ID\n   * @returns {Promise<Object>} The pricing data for the card\n   */\n  async getCardPricing(cardId) {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardPricing, 'readonly');\n      const store = transaction.objectStore(STORES.cardPricing);\n      \n      const request = store.get(cardId);\n      \n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          // If we have the data in the cache, return it\n          if (request.result && request.result.data) {\n            resolve(request.result.data);\n          } else {\n            // No data found\n            resolve(null);\n          }\n        };\n        \n        request.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error getting pricing data for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Check if we have cards for a specific set in the cache\n   * @param {string} setCode - The set code\n   * @returns {Promise<boolean>} True if we have the data, false otherwise\n   */\n  async hasCardsForSet(setCode) {\n    try {\n      // Use a fallback key if setCode is null or undefined\n      const storageKey = setCode || 'unknown-set';\n      \n      const cards = await this.getCardsForSet(storageKey);\n      return cards !== null;\n    } catch (error) {\n      console.error(`Error checking if we have cards for set ${setCode}:`, error);\n      return false;\n    }\n  },\n  \n  /**\n   * Clear specific set data\n   * @param {string} setCode - The set code to clear\n   * @returns {Promise<void>}\n   */\n  async clearSetData(setCode) {\n    try {\n      // Use a fallback key if setCode is null or undefined\n      const storageKey = setCode || 'unknown-set';\n      \n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardsBySet, 'readwrite');\n      const store = transaction.objectStore(STORES.cardsBySet);\n      \n      const request = store.delete(storageKey);\n      \n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          console.log(`Cleared cache for set ${setCode}`);\n          resolve();\n        };\n        request.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error clearing data for set ${setCode}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Clear pricing data for a specific card\n   * @param {string} cardId - The card ID to clear\n   * @returns {Promise<void>}\n   */\n  async clearCardPricing(cardId) {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardPricing, 'readwrite');\n      const store = transaction.objectStore(STORES.cardPricing);\n      \n      const request = store.delete(cardId);\n      \n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          console.log(`Cleared pricing cache for card ${cardId}`);\n          resolve();\n        };\n        request.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error clearing pricing data for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Clear all stored data (useful for testing or resets)\n   * @returns {Promise<void>}\n   */\n  async storeCardPricing(cardId, pricingData) {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardPricing, 'readwrite');\n      const store = transaction.objectStore(STORES.cardPricing);\n      \n      await store.put({\n        id: cardId,\n        data: pricingData,\n        timestamp: Date.now()\n      });\n      \n      return new Promise((resolve, reject) => {\n        transaction.oncomplete = () => resolve();\n        transaction.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error storing pricing for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get card pricing data\n   * @param {string} cardId - The card ID\n   * @returns {Promise<Object>} The pricing data\n   */\n  async getCardPricing(cardId) {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction(STORES.cardPricing, 'readonly');\n      const store = transaction.objectStore(STORES.cardPricing);\n      \n      const request = store.get(cardId);\n      \n      return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n          // If we have the data in the cache, return it\n          if (request.result && request.result.data) {\n            resolve(request.result.data);\n          } else {\n            // No data found\n            resolve(null);\n          }\n        };\n        \n        request.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error(`Error getting pricing for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n  \n  async clearAllData() {\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction([STORES.setList, STORES.cardsBySet, STORES.cardPricing], 'readwrite');\n      \n      transaction.objectStore(STORES.setList).clear();\n      transaction.objectStore(STORES.cardsBySet).clear();\n      transaction.objectStore(STORES.cardPricing).clear();\n      \n      return new Promise((resolve, reject) => {\n        transaction.oncomplete = () => {\n          console.log('All cache data cleared successfully');\n          resolve();\n        };\n        transaction.onerror = (event) => reject(event.target.error);\n      });\n    } catch (error) {\n      console.error('Error clearing all data:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Delete the entire database\n   * @returns {Promise<void>}\n   */\n  async resetDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.deleteDatabase(DB_NAME);\n      \n      request.onsuccess = () => {\n        console.log(`Database ${DB_NAME} deleted successfully`);\n        resolve();\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error deleting database:', event.target.error);\n        reject(event.target.error);\n      };\n      \n      request.onblocked = () => {\n        console.warn('Database deletion blocked - may have open connections');\n        // Still attempt to continue\n        resolve();\n      };\n    });\n  }\n};","import { fetchWithProxy } from '../corsProxy';\nimport { API_CONFIG } from '../data/apiConfig';\nimport { dbService } from './storage/db';\n\n/**\n * Helper function to sort sets by release date in descending order\n * @param {Array} sets - Array of set objects\n * @returns {Array} - Sorted array of sets\n */\nfunction sortSetsByReleaseDate(sets) {\n  return sets.sort((a, b) => {\n    // Compare release dates in descending order (newest first)\n    const dateA = new Date(a.release_date || 0);\n    const dateB = new Date(b.release_date || 0);\n    return dateB - dateA;\n  });\n}\n\n/**\n * Helper function to ensure all sets have unique IDs\n * @param {Array} sets - Array of set objects\n * @returns {Array} - Array of sets with guaranteed IDs\n */\nfunction ensureSetsHaveIds(sets) {\n  if (!sets || !Array.isArray(sets)) return [];\n  \n  let highestId = 0;\n  \n  // Find the highest existing ID\n  sets.forEach(set => {\n    if (set.id && typeof set.id === 'number' && set.id > highestId) {\n      highestId = set.id;\n    }\n  });\n  \n  // Ensure all sets have an ID\n  return sets.map(set => {\n    // If the set already has an ID, return it unchanged\n    if (set.id) return set;\n    \n    // Otherwise, assign a new unique ID\n    highestId += 1;\n    return { ...set, id: highestId };\n  });\n}\n\n/**\n * Service for Pokémon data operations\n */\nexport const pokeDataService = {\n  /**\n   * Get the list of all Pokémon card sets\n   * @returns {Promise<Array>} Array of set objects\n   */\n  async getSetList() {\n    try {\n      console.log('Fetching set list...');\n      // First try to get from cache\n      const cachedSets = await dbService.getSetList();\n      if (cachedSets && cachedSets.length > 0) {\n        console.log(`Using cached sets data - ${cachedSets.length} sets`);\n        return sortSetsByReleaseDate(ensureSetsHaveIds(cachedSets));\n      }\n      \n      // If not in cache, fetch from API\n      const url = API_CONFIG.buildSetsUrl();\n      console.log(`Fetching sets from API: ${url}`);\n      \n      const response = await fetchWithProxy(url, {\n        headers: API_CONFIG.getHeaders()\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unable to get error details');\n        console.error(`API error: ${response.status} - ${errorText}`);\n        throw new Error(`API error: ${response.status}. Details: ${errorText}`);\n      }\n      \n      const data = await response.json();\n      console.log('API response for sets:', data);\n      \n      // Check for different response formats\n      let setsData = data;\n      \n      // Handle data wrapper\n      if (!Array.isArray(data) && data.data && Array.isArray(data.data)) {\n        console.log('Found data wrapper in sets response');\n        setsData = data.data;\n      }\n      \n      // Handle sets wrapper\n      if (!Array.isArray(data) && data.sets && Array.isArray(data.sets)) {\n        console.log('Found sets wrapper in response');\n        setsData = data.sets;\n      }\n      \n      // Ensure all sets have IDs\n      const processedData = ensureSetsHaveIds(setsData);\n      console.log(`Processed ${processedData.length} sets with IDs`);\n      \n      // Cache the results\n      if (processedData && Array.isArray(processedData)) {\n        await dbService.saveSetList(processedData);\n      }\n      \n      return sortSetsByReleaseDate(processedData);\n    } catch (error) {\n      console.error('Error fetching sets:', error);\n      // Return the fallback list which already has IDs\n      console.log('Using hard-coded fallback set list due to API error');\n      const { setList } = await import('../data/setList');\n      return sortSetsByReleaseDate(setList);\n    }\n  },\n  \n  /**\n   * Get cards for a specific set\n   * @param {string} setCode - The set code\n   * @param {string} setId - The set ID (required)\n   * @returns {Promise<Array>} Array of card objects\n   */\n  async getCardsForSet(setCode, setId) {\n    try {\n      if (!setId) {\n        console.error('Set ID is required to fetch cards');\n        return [];\n      }\n      \n      // Log any potential issues with set code\n      if (!setCode) {\n        console.warn('Set code is null or undefined, using fallback key for cache');\n        // Use setId as fallback cache key if setCode is missing\n        setCode = `id_${setId}`;\n      }\n      \n      // Try to get from cache first\n      const cachedCards = await dbService.getCardsForSet(setCode);\n      if (cachedCards && cachedCards.length > 0) {\n        console.log(`Using cached cards for set ${setCode}: ${cachedCards.length} cards`);\n        return cachedCards;\n      }\n      \n      console.log(`Fetching cards for set ${setCode} (ID: ${setId}) from API...`);\n      \n      // If not in cache, fetch from API using set_id\n      const url = API_CONFIG.buildCardsForSetUrl(setId);\n      console.log(`API URL for cards: ${url}`);\n      \n      const response = await fetchWithProxy(url, {\n        headers: API_CONFIG.getHeaders()\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unable to get error details');\n        console.error(`API error for set ${setCode}: ${response.status} - ${errorText}`);\n        throw new Error(`API error: ${response.status}. Details: ${errorText}`);\n      }\n      \n      const data = await response.json();\n      console.log(`API response for set ${setCode}:`, data);\n      \n      // Process the cards data\n      let cards = [];\n      \n      // Check if we have a cards property in the response\n      if (data && data.cards && Array.isArray(data.cards)) {\n        console.log(`Found cards array with ${data.cards.length} items`);\n        cards = data.cards;\n      }\n      // If no cards property, check if the response itself is an array of cards\n      else if (data && Array.isArray(data)) {\n        console.log(`Response is a direct array with ${data.length} items`);\n        cards = data;\n      }\n      // If we have a data property with an array\n      else if (data && data.data && Array.isArray(data.data)) {\n        console.log(`Response has a data array with ${data.data.length} items`);\n        cards = data.data;\n      }\n      // If we have a results property with an array\n      else if (data && data.results && Array.isArray(data.results)) {\n        console.log(`Response has a results array with ${data.results.length} items`);\n        cards = data.results;\n      }\n      else {\n        console.warn('Unexpected data format:', data);\n        // Try to extract cards from any array property as a last resort\n        for (const key in data) {\n          if (Array.isArray(data[key]) && data[key].length > 0) {\n            console.log(`Found potential cards array in property '${key}' with ${data[key].length} items`);\n            cards = data[key];\n            break;\n          }\n        }\n      }\n      \n      // If we found any cards, log the first one as a sample\n      if (cards.length > 0) {\n        console.log('First card sample:', cards[0]);\n      }\n      \n      // Log the number of cards found\n      console.log(`Found ${cards.length} cards for set ${setCode}`);\n      \n      // Cache the results if we have cards\n      if (cards.length > 0) {\n        await dbService.saveCardsForSet(setCode, cards);\n      }\n      \n      return cards;\n    } catch (error) {\n      console.error(`Error fetching cards for set ${setCode}:`, error);\n      return [];\n    }\n  },\n  \n  /**\n   * Get pricing data for a specific card\n   * @param {string} cardId - The card ID\n   * @returns {Promise<Object>} Card pricing data\n   */\n  async getCardPricing(cardId) {\n    try {\n      if (!cardId) {\n        throw new Error('Card ID is required to fetch pricing data');\n      }\n\n      console.log(`Getting pricing data for card ID: ${cardId}`);\n      \n      // Try to get from cache first\n      const cachedPricing = await dbService.getCardPricing(cardId);\n      if (cachedPricing) {\n        console.log(`Using cached pricing for card ${cardId}`);\n        return cachedPricing;\n      }\n      \n      // If not in cache, fetch from API\n      const url = API_CONFIG.buildPricingUrl(cardId);\n      console.log(`API URL for pricing: ${url}`);\n      \n      const response = await fetchWithProxy(url, {\n        headers: API_CONFIG.getHeaders()\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Unable to get error details');\n        console.error(`API error for pricing ${cardId}: ${response.status} - ${errorText}`);\n        throw new Error(`API error: ${response.status}. Details: ${errorText}`);\n      }\n      \n      const data = await response.json();\n      console.log(`Pricing API response for card ${cardId}:`, data);\n      \n      // Process the pricing data based on the API response format\n      let pricingData = data;\n      \n      // Check if the API returns a data wrapper object\n      if (data && data.data && typeof data.data === 'object') {\n        console.log('Found data wrapper in pricing response');\n        pricingData = data.data;\n      }\n      \n      // Cache the results\n      if (pricingData) {\n        await dbService.saveCardPricing(cardId, pricingData);\n      }\n      \n      return pricingData;\n    } catch (error) {\n      console.error(`Error fetching pricing for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Load mock data for testing when API is unavailable\n   * @param {string} setName - The set name\n   * @param {string} cardName - The card name\n   * @returns {Promise<Object>} Mock card pricing data\n   */\n  async loadMockData(setName, cardName) {\n    try {\n      const response = await fetch('./mock/pricing-response.json');\n      const mockData = await response.json();\n      \n      // Customize the mock data\n      mockData.name = cardName || 'Charizard';\n      mockData.set_name = setName || 'Base Set';\n      \n      return mockData;\n    } catch (error) {\n      console.error('Error loading mock data:', error);\n      \n      // Return minimal mock data if JSON file fails to load\n      return {\n        id: 'mock-id',\n        name: cardName || 'Charizard',\n        set_name: setName || 'Base Set',\n        num: '4/102',\n        rarity: 'Rare Holo',\n        pricing: {\n          'market': { value: 299.99, currency: 'USD' },\n          'tcgplayer': { value: 305.42, currency: 'USD' }\n        }\n      };\n    }\n  }\n};","<script>\n  import { createEventDispatcher, onMount } from 'svelte';\n  \n  // Props\n  export let items = [];\n  export let placeholder = 'Search...';\n  export let labelField = 'name';\n  export let secondaryField = null;\n  export let value = null;\n  \n  // State\n  let searchText = '';\n  let showDropdown = false;\n  let filteredItems = [];\n  let highlightedIndex = -1;\n  let inputElement;\n  let dropdownElement;\n  \n  const dispatch = createEventDispatcher();\n  \n  // Update searchText when value changes and user is not typing\n  $: if (value) {\n    if (!inputElement || !inputElement.matches(':focus')) {\n      searchText = getDisplayText(value);\n    }\n  }\n  \n  // Update filtered items when items or searchText changes\n  $: {\n    console.log('Filtering items with searchText:', searchText);\n    \n    if (items && Array.isArray(items)) {\n      // Only filter if there's search text, otherwise show all items\n      if (searchText && searchText.trim() !== '' && (!value || searchText !== getDisplayText(value))) {\n        const searchLower = searchText.toLowerCase();\n        filteredItems = items.filter(item => {\n          if (!item || !item[labelField]) return false;\n          \n          const primaryMatch = item[labelField].toLowerCase().includes(searchLower);\n          const secondaryMatch = secondaryField && item[secondaryField] && \n                                 item[secondaryField].toLowerCase().includes(searchLower);\n          return primaryMatch || secondaryMatch;\n        });\n      } else {\n        filteredItems = [...items];\n      }\n      \n      console.log(`Filtered to ${filteredItems.length} items`);\n    } else {\n      filteredItems = [];\n    }\n    \n    // Reset highlighted index whenever items change\n    highlightedIndex = -1;\n  }\n  \n  function handleFocus() {\n    console.log('Input focused');\n    showDropdown = true;\n  }\n  \n  function closeDropdown() {\n    showDropdown = false;\n  }\n  \n  function handleKeydown(event) {\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        if (!showDropdown) showDropdown = true;\n        highlightedIndex = Math.min(highlightedIndex + 1, filteredItems.length - 1);\n        scrollToHighlighted();\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        if (!showDropdown) showDropdown = true;\n        highlightedIndex = Math.max(highlightedIndex - 1, -1);\n        scrollToHighlighted();\n        break;\n      case 'Enter':\n        if (showDropdown && highlightedIndex >= 0 && highlightedIndex < filteredItems.length) {\n          handleItemSelect(filteredItems[highlightedIndex]);\n        }\n        break;\n      case 'Escape':\n        closeDropdown();\n        break;\n    }\n  }\n  \n  function scrollToHighlighted() {\n    if (highlightedIndex >= 0 && dropdownElement) {\n      const highlightedEl = dropdownElement.querySelector(`.item-${highlightedIndex}`);\n      if (highlightedEl) {\n        highlightedEl.scrollIntoView({ block: 'nearest' });\n      }\n    }\n  }\n  \n  function handleItemSelect(item) {\n    if (!item) return;\n    \n    // Update the internal value and search text\n    value = item;\n    searchText = getDisplayText(item);\n    \n    // Close dropdown\n    closeDropdown();\n    \n    // Dispatch the select event\n    dispatch('select', item);\n  }\n  \n  function getDisplayText(item) {\n    if (!item) return '';\n    if (secondaryField && item[secondaryField]) {\n      return `${item[labelField]} (${item[secondaryField]})`;\n    }\n    return item[labelField];\n  }\n  \n  function handleInput() {\n    // Open dropdown when typing\n    showDropdown = true;\n    \n    // If text changed and user had a selection, clear it\n    if (value && searchText !== getDisplayText(value)) {\n      console.log('Text changed, clearing selection');\n      value = null;\n      dispatch('select', null);\n    }\n  }\n  \n  // Function to be called from outside to clear selection\n  export function clearSelection() {\n    console.log('Clearing selection programmatically');\n    value = null;\n    searchText = '';\n    showDropdown = true;\n    filteredItems = [...items];\n    dispatch('select', null);\n    \n    // Focus the input\n    if (inputElement) {\n      inputElement.focus();\n    }\n  }\n  \n  // Handle clicks outside the component to close the dropdown\n  function handleOutsideClick(event) {\n    if (showDropdown && inputElement && !dropdownElement.contains(event.target) && !inputElement.contains(event.target)) {\n      closeDropdown();\n    }\n  }\n  \n  // Set up event listeners on mount\n  onMount(() => {\n    document.addEventListener('click', handleOutsideClick);\n    return () => {\n      document.removeEventListener('click', handleOutsideClick);\n    };\n  });\n</script>\n\n<div class=\"searchable-select\">\n  <div class=\"input-wrapper\">\n    <input\n      type=\"text\"\n      bind:this={inputElement}\n      bind:value={searchText}\n      on:input={handleInput}\n      on:focus={handleFocus}\n      on:keydown={handleKeydown}\n      placeholder={placeholder}\n      autocomplete=\"off\"\n    />\n    <span class=\"dropdown-icon\">{showDropdown ? '▲' : '▼'}</span>\n  </div>\n  \n  {#if showDropdown}\n    <div class=\"dropdown\" bind:this={dropdownElement}>\n      {#if filteredItems.length === 0}\n        <div class=\"no-results\">No results found</div>\n      {:else}\n        {#each filteredItems as item, index}\n          <div\n            class=\"item item-{index} {highlightedIndex === index ? 'highlighted' : ''}\"\n            on:click={() => handleItemSelect(item)}\n            on:mouseover={() => highlightedIndex = index}\n          >\n            <span class=\"label\">\n              {item[labelField]}\n              {#if secondaryField && item[secondaryField]}\n                <span class=\"secondary\">({item[secondaryField]})</span>\n              {/if}\n            </span>\n          </div>\n        {/each}\n      {/if}\n    </div>\n  {/if}\n</div>\n\n<style>\n  .searchable-select {\n    position: relative;\n    width: 100%;\n  }\n  \n  .input-wrapper {\n    position: relative;\n  }\n  \n  input {\n    width: 100%;\n    padding: 0.5rem;\n    padding-right: 2rem;\n    font-size: 1rem;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n  }\n  \n  .dropdown-icon {\n    position: absolute;\n    right: 0.5rem;\n    top: 50%;\n    transform: translateY(-50%);\n    color: #666;\n    pointer-events: none;\n  }\n  \n  .dropdown {\n    position: absolute;\n    top: 100%;\n    left: 0;\n    width: 100%;\n    max-height: 300px;\n    overflow-y: auto;\n    background-color: white;\n    border: 1px solid #ddd;\n    border-radius: 0 0 4px 4px;\n    z-index: 10;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  }\n  \n  .item {\n    padding: 0.5rem;\n    cursor: pointer;\n    color: #333; /* Added explicit text color */\n    border-bottom: 1px solid #f5f5f5;\n  }\n  \n  .item:last-child {\n    border-bottom: none;\n  }\n  \n  .item:hover, .highlighted {\n    background-color: #f5f5f5;\n    color: #3c5aa6; /* Blue color on hover */\n  }\n  \n  .label {\n    color: inherit; /* Use the parent element's color */\n  }\n  \n  .secondary {\n    color: #666;\n    font-size: 0.9rem;\n    margin-left: 0.25rem;\n  }\n  \n  .no-results {\n    padding: 0.5rem;\n    color: #666;\n    font-style: italic;\n    text-align: center;\n  }\n</style>","<script>\n  import { createEventDispatcher, onMount } from 'svelte';\n  \n  // Props\n  export let cards = [];  // This will be the list of cards from the selected set\n  export let placeholder = 'Search for a card...';\n  export let selectedCard = null;  // Two-way binding\n  \n  // Local state\n  let searchText = '';\n  let showDropdown = false;\n  let filteredCards = [];\n  let highlightedIndex = -1;\n  let inputElement;\n  let dropdownElement;\n  \n  // Set up event dispatcher\n  const dispatch = createEventDispatcher();\n  \n  // Function to generate display text for a card (with number if available)\n  function getCardDisplayText(card) {\n    if (!card) return '';\n    return card.num ? `${card.name} (${card.num})` : card.name;\n  }\n  \n  // Watch for changes to selectedCard and update searchText only when input doesn't have focus\n  $: if (selectedCard && selectedCard.name && inputElement && !inputElement.matches(':focus')) {\n    searchText = getCardDisplayText(selectedCard);\n  }\n  \n  // Update filtered cards when cards or searchText changes\n  $: {\n    console.log(`Filtering ${cards.length} cards with search: \"${searchText}\"`);\n    \n    if (searchText && searchText.trim() !== '') {\n      const search = searchText.toLowerCase().trim();\n      \n      filteredCards = cards.filter(card => {\n        // Skip cards without a name\n        if (!card || !card.name) return false;\n        \n        // Match on name\n        const nameMatch = card.name.toLowerCase().includes(search);\n        \n        // Also match on card number if available\n        const numMatch = card.num && card.num.toLowerCase().includes(search);\n        \n        return nameMatch || numMatch;\n      });\n      \n      // Always show dropdown when searching\n      if (inputElement && inputElement.matches(':focus')) {\n        showDropdown = true;\n      }\n    } else {\n      // When empty, show all cards (up to a reasonable limit)\n      filteredCards = [...cards].slice(0, 100);\n    }\n    \n    // Reset highlight when results change\n    highlightedIndex = -1;\n    \n    console.log(`Filtered to ${filteredCards.length} cards`);\n  }\n  \n  // Handle input changes\n  function handleInput() {\n    console.log(\"Input changed:\", searchText);\n    showDropdown = true;\n    \n    // If text no longer matches the selected card, clear the selection immediately\n    if (selectedCard && searchText !== getCardDisplayText(selectedCard)) {\n      console.log(\"Text doesn't match selected card, clearing selection\");\n      selectedCard = null;\n      dispatch('select', null);\n    }\n  }\n  \n  // Handle focus on the input\n  function handleFocus() {\n    console.log(\"Input focused\");\n    showDropdown = true;\n  }\n  \n  // Handle selection of a card\n  function handleSelect(card) {\n    console.log(\"Card selected:\", card?.name);\n    \n    if (!card) return;\n    \n    selectedCard = card;\n    searchText = getCardDisplayText(card);\n    \n    // Close dropdown\n    closeDropdown();\n    dispatch('select', card);\n  }\n  \n  // Close the dropdown\n  function closeDropdown() {\n    showDropdown = false;\n  }\n  \n  // Handle keyboard navigation\n  function handleKeydown(event) {\n    if (!showDropdown) return;\n    \n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        highlightedIndex = Math.min(highlightedIndex + 1, filteredCards.length - 1);\n        scrollToHighlighted();\n        break;\n        \n      case 'ArrowUp':\n        event.preventDefault();\n        highlightedIndex = Math.max(highlightedIndex - 1, -1);\n        scrollToHighlighted();\n        break;\n        \n      case 'Enter':\n        if (highlightedIndex >= 0 && highlightedIndex < filteredCards.length) {\n          handleSelect(filteredCards[highlightedIndex]);\n        }\n        break;\n        \n      case 'Escape':\n        closeDropdown();\n        break;\n        \n      case 'Backspace':\n        // Special case for backspace - ensure dropdown stays open\n        if (searchText.length <= 1) {\n          setTimeout(() => {\n            showDropdown = true;\n          }, 0);\n        }\n        break;\n    }\n  }\n  \n  // Scroll to highlighted item in the dropdown\n  function scrollToHighlighted() {\n    if (highlightedIndex >= 0 && dropdownElement) {\n      const highlightedEl = dropdownElement.querySelector(`.card-item-${highlightedIndex}`);\n      if (highlightedEl) {\n        highlightedEl.scrollIntoView({ block: 'nearest' });\n      }\n    }\n  }\n  \n  // Function to clear the current selection (to be called from parent)\n  export function clearSelection() {\n    console.log(\"Clearing card selection\");\n    selectedCard = null;\n    searchText = '';\n    dispatch('select', null);\n    \n    // Keep dropdown closed after clear unless user focuses the input\n    showDropdown = false;\n    \n    // Optional: focus the input after clearing\n    if (inputElement) {\n      inputElement.focus();\n    }\n  }\n  \n  // Focus the input after clearing and show dropdown\n  export function clearAndFocus() {\n    clearSelection();\n    \n    // Focus the input\n    if (inputElement) {\n      inputElement.focus();\n      \n      // Ensure dropdown is shown\n      setTimeout(() => {\n        showDropdown = true;\n        \n        // Force refilter with empty search\n        searchText = '';\n        filteredCards = [...cards].slice(0, 100);\n      }, 10);\n    }\n  }\n  \n  // Handle clicks outside the component to close the dropdown\n  function handleOutsideClick(event) {\n    if (showDropdown && inputElement && !dropdownElement.contains(event.target) && !inputElement.contains(event.target)) {\n      closeDropdown();\n    }\n  }\n  \n  // Set up event listeners on mount\n  onMount(() => {\n    document.addEventListener('click', handleOutsideClick);\n    return () => {\n      document.removeEventListener('click', handleOutsideClick);\n    };\n  });\n</script>\n\n<div class=\"card-search\">\n  <div class=\"input-wrapper\">\n    <input\n      type=\"text\"\n      bind:this={inputElement}\n      bind:value={searchText}\n      on:input={handleInput}\n      on:focus={handleFocus}\n      on:keydown={handleKeydown}\n      placeholder={placeholder}\n      autocomplete=\"off\"\n    />\n    <span class=\"icon\">{showDropdown ? '▲' : '▼'}</span>\n  </div>\n  \n  {#if showDropdown}\n    <div class=\"dropdown\" bind:this={dropdownElement}>\n      {#if filteredCards.length === 0}\n        <div class=\"no-results\">No matching cards found</div>\n      {:else}\n        {#each filteredCards as card, index}\n          <div\n            class=\"card-item card-item-{index} {highlightedIndex === index ? 'highlighted' : ''}\"\n            on:click={() => handleSelect(card)}\n            on:mouseover={() => highlightedIndex = index}\n          >\n            <div class=\"card-info\">\n              <span class=\"card-name\">\n                {card.name}\n                {#if card.num}\n                  <span class=\"card-num\">({card.num})</span>\n                {/if}\n              </span>\n            </div>\n          </div>\n        {/each}\n      {/if}\n    </div>\n  {/if}\n</div>\n\n<style>\n  .card-search {\n    position: relative;\n    width: 100%;\n  }\n  \n  .input-wrapper {\n    position: relative;\n  }\n  \n  input {\n    width: 100%;\n    padding: 0.6rem 0.75rem;\n    padding-right: 2rem;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 1rem;\n    transition: border-color 0.3s ease;\n  }\n  \n  input:focus {\n    outline: none;\n    border-color: #3c5aa6;\n    box-shadow: 0 0 0 2px rgba(60, 90, 166, 0.2);\n  }\n  \n  .icon {\n    position: absolute;\n    right: 0.5rem;\n    top: 50%;\n    transform: translateY(-50%);\n    color: #666;\n    pointer-events: none;\n  }\n  \n  .dropdown {\n    position: absolute;\n    top: 100%;\n    left: 0;\n    width: 100%;\n    max-height: 300px;\n    overflow-y: auto;\n    background-color: white;\n    border: 1px solid #ddd;\n    border-top: none;\n    border-radius: 0 0 4px 4px;\n    z-index: 10;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n    margin-top: -1px;\n  }\n  \n  .card-item {\n    width: 100%;\n    text-align: left;\n    padding: 0.5rem 0.75rem;\n    background: none;\n    border: none;\n    border-bottom: 1px solid #f0f0f0;\n    cursor: pointer;\n    font-size: 1rem;\n    transition: background-color 0.15s ease;\n    color: #333;\n  }\n  \n  .card-item:last-child {\n    border-bottom: none;\n  }\n  \n  .card-item:hover, .highlighted {\n    background-color: #f0f0f0;\n    color: #3c5aa6;\n  }\n  \n  .card-info {\n    display: flex;\n    width: 100%;\n  }\n  \n  .card-name {\n    font-weight: 500;\n    color: inherit;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  \n  .card-num {\n    font-weight: normal;\n    color: #666;\n    font-size: 0.9rem;\n    margin-left: 4px;\n  }\n  \n  .no-results {\n    padding: 0.75rem;\n    color: #666;\n    font-style: italic;\n    text-align: center;\n  }\n</style>","<script>\n  import { createEventDispatcher } from 'svelte';\n  \n  // Props\n  export let variants = [];\n  export let isVisible = false;\n  \n  // State\n  let selectedVariant = null;\n  \n  const dispatch = createEventDispatcher();\n  \n  // Functions\n  function selectVariant(variant) {\n    selectedVariant = variant;\n    dispatch('select', variant);\n  }\n  \n  function close() {\n    dispatch('close');\n  }\n  \n  // Reset selected variant when variants change\n  $: {\n    if (variants && variants.length) {\n      selectedVariant = null;\n    }\n  }\n  \n  // Determine if a variant is selected\n  function isSelected(variant) {\n    return selectedVariant && selectedVariant.id === variant.id;\n  }\n</script>\n\n{#if isVisible && variants.length > 0}\n  <div class=\"overlay\" on:click={close}>\n    <div class=\"modal\" on:click|stopPropagation>\n      <div class=\"modal-header\">\n        <h3>Multiple Variants Found</h3>\n        <button class=\"close-button\" on:click={close}>&times;</button>\n      </div>\n      \n      <div class=\"modal-body\">\n        <p>Multiple versions of \"{variants[0]?.name}\" were found in this set. Please select the specific variant:</p>\n        \n        <div class=\"variants-list\">\n          {#each variants as variant}\n            <div \n              class=\"variant-item {isSelected(variant) ? 'selected' : ''}\"\n              on:click={() => selectVariant(variant)}\n            >\n              <div class=\"variant-details\">\n                <div class=\"variant-name\">{variant.name}</div>\n                <div class=\"variant-info\">\n                  <span class=\"variant-number\">#{variant.num}</span>\n                  {#if variant.rarity}\n                    <span class=\"variant-rarity\">{variant.rarity}</span>\n                  {/if}\n                  {#if variant.variant}\n                    <span class=\"variant-type\">{variant.variant}</span>\n                  {/if}\n                </div>\n                {#if variant.image_url}\n                  <div class=\"variant-thumbnail\">\n                    <img src={variant.image_url} alt={variant.name} />\n                  </div>\n                {/if}\n              </div>\n            </div>\n          {/each}\n        </div>\n      </div>\n      \n      <div class=\"modal-footer\">\n        <button \n          class=\"confirm-button\" \n          disabled={!selectedVariant}\n          on:click={() => {\n            if (selectedVariant) {\n              dispatch('confirm', selectedVariant);\n              close();\n            }\n          }}\n        >\n          Select Variant\n        </button>\n        <button class=\"cancel-button\" on:click={close}>\n          Cancel\n        </button>\n      </div>\n    </div>\n  </div>\n{/if}\n\n<style>\n  .overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(0, 0, 0, 0.5);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 100;\n  }\n  \n  .modal {\n    background-color: white;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 600px;\n    max-height: 80vh;\n    overflow-y: auto;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n    display: flex;\n    flex-direction: column;\n  }\n  \n  .modal-header {\n    padding: 1rem;\n    border-bottom: 1px solid #ddd;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n  \n  .modal-header h3 {\n    margin: 0;\n    color: #3c5aa6;\n  }\n  \n  .close-button {\n    background: none;\n    border: none;\n    font-size: 1.5rem;\n    cursor: pointer;\n    color: #666;\n    padding: 0;\n    margin: 0;\n    line-height: 1;\n  }\n  \n  .modal-body {\n    padding: 1rem;\n    overflow-y: auto;\n  }\n  \n  .variants-list {\n    margin-top: 1rem;\n    max-height: 300px;\n    overflow-y: auto;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n  }\n  \n  .variant-item {\n    padding: 0.75rem;\n    border-bottom: 1px solid #ddd;\n    cursor: pointer;\n    transition: background-color 0.2s;\n  }\n  \n  .variant-item:last-child {\n    border-bottom: none;\n  }\n  \n  .variant-item:hover {\n    background-color: #f5f5f5;\n  }\n  \n  .variant-item.selected {\n    background-color: rgba(60, 90, 166, 0.1);\n    border-left: 3px solid #3c5aa6;\n  }\n  \n  .variant-details {\n    display: flex;\n    flex-direction: column;\n  }\n  \n  .variant-name {\n    font-weight: 600;\n    margin-bottom: 0.25rem;\n  }\n  \n  .variant-info {\n    display: flex;\n    gap: 0.75rem;\n    margin-bottom: 0.5rem;\n    font-size: 0.9rem;\n  }\n  \n  .variant-number {\n    color: #666;\n  }\n  \n  .variant-rarity {\n    color: #ee1515;\n    font-weight: 500;\n  }\n  \n  .variant-type {\n    color: #3c5aa6;\n    font-style: italic;\n  }\n  \n  .variant-thumbnail {\n    margin-top: 0.5rem;\n    max-width: 100px;\n  }\n  \n  .variant-thumbnail img {\n    width: 100%;\n    height: auto;\n    border-radius: 4px;\n    border: 1px solid #ddd;\n  }\n  \n  .modal-footer {\n    padding: 1rem;\n    border-top: 1px solid #ddd;\n    display: flex;\n    justify-content: flex-end;\n    gap: 0.75rem;\n  }\n  \n  .confirm-button {\n    background-color: #ee1515;\n    color: white;\n    border: none;\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n    font-weight: 600;\n  }\n  \n  .confirm-button:disabled {\n    background-color: #ccc;\n    cursor: not-allowed;\n  }\n  \n  .cancel-button {\n    background-color: #f5f5f5;\n    color: #333;\n    border: 1px solid #ddd;\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n  }\n</style>","<script>\n  import { onMount } from 'svelte';\n  import { API_CONFIG } from './data/apiConfig';\n  import { pokeDataService } from './services/pokeDataService';\n  import { dbService } from './services/storage/db';\n  import SearchableSelect from './components/SearchableSelect.svelte';\n  import CardSearchSelect from './components/CardSearchSelect.svelte';\n  import CardVariantSelector from './components/CardVariantSelector.svelte';\n  \n  // Reference to CardSearchSelect component\n  let cardSearchComponent;\n  \n  let selectedSet = null;\n  let cardName = '';\n  let priceData = null;\n  let isLoading = false;\n  let error = null;\n  let availableSets = [];\n  \n  // New state variables for cards\n  let cardsInSet = [];\n  let isLoadingCards = false;\n  let selectedCard = null;\n  \n  // Variables for handling card variants\n  let cardVariants = [];\n  let showVariantSelector = false;\n  let selectedVariant = null;\n  \n  // Format price to always show 2 decimal places\n  function formatPrice(value) {\n    if (value === undefined || value === null) return \"0.00\";\n    return parseFloat(value).toFixed(2);\n  }\n\n  // Handle set selection\n  async function handleSetSelect(event) {\n    selectedSet = event.detail;\n    console.log('Selected set:', selectedSet);\n    // Verify we have the set ID before loading cards\n    if (selectedSet && selectedSet.id) {\n      loadCardsForSet(selectedSet);\n    } else {\n      console.error('Selected set does not have an ID property:', selectedSet);\n      error = 'Invalid set data. Please select a different set.';\n    }\n  }\n  \n  // Load cards for a selected set\n  async function loadCardsForSet(set) {\n    if (!set) return;\n    if (!set.id) {\n      console.error('Set ID is required but not available:', set);\n      error = \"Selected set is missing required data.\";\n      return;\n    }\n    \n    try {\n      // Clear all card-related state first\n      priceData = null;\n      selectedCard = null;\n      cardName = '';\n      cardsInSet = [];\n      \n      // Show loading state\n      isLoadingCards = true;\n      error = null;\n      \n      console.log(`Loading cards for set ${set.name} (code: ${set.code}, id: ${set.id})...`);\n      \n      // Get cards for the selected set using the pokeDataService\n      let cards = await pokeDataService.getCardsForSet(set.code, set.id);\n      \n      // If no cards returned, try to use fallback data for certain sets\n      if (!cards || cards.length === 0) {\n        console.log(`No cards returned from API for set ${set.code}, trying fallback data`);\n        \n        // Use fallback data for Prismatic Evolutions set\n        if (set.code === 'PRE') {\n          console.log('Using fallback data for Prismatic Evolutions');\n          cards = prismaticEvolutionsCards;\n        } else {\n          // Generate some dummy cards for other sets\n          console.log(`Generating dummy cards for set ${set.code}`);\n          cards = Array.from({ length: 20 }, (_, i) => ({\n            id: `dummy-${set.code}-${i+1}`,\n            name: `${set.name} Card ${i+1}`,\n            num: `${i+1}/${100}`,\n            set_code: set.code,\n            set_name: set.name\n          }));\n        }\n      }\n      \n      console.log(`Received ${cards ? cards.length : 0} cards from API/cache`);\n      \n      if (!cards || cards.length === 0) {\n        console.log('No cards returned for this set');\n        isLoadingCards = false;\n        return;\n      }\n      \n      // Check if cards have the expected properties\n      const sampleCard = cards[0];\n      console.log('Sample card structure:', sampleCard);\n      \n      console.log(`Received ${cards.length} cards for set ${set.name}`);\n      \n      // Transform the cards into a format suitable for the SearchableSelect component\n      cardsInSet = cards.map(card => ({\n        id: card.id || `fallback-${card.num || Math.random()}`,\n        name: card.name || 'Unknown Card',\n        num: card.num || '',\n        rarity: card.rarity || '',\n        variant: card.variant || '',\n        image_url: card.image_url || ''\n      }));\n      \n      console.log(`Transformed ${cardsInSet.length} cards for display`);\n      \n      // Check if any cards lack name property\n      const invalidCards = cards.filter(card => !card.name);\n      if (invalidCards.length > 0) {\n        console.warn(`Found ${invalidCards.length} cards without names!`);\n        console.warn('Sample invalid card:', invalidCards[0]);\n      }\n      \n      isLoadingCards = false;\n      \n      isLoadingCards = false;\n    } catch (err) {\n      console.error('Error loading cards for set:', err);\n      isLoadingCards = false;\n      cardsInSet = []; // Reset to empty array in case of error\n    }\n  }\n  \n  // Function to handle card selection changes\n  function handleCardSelect(event) {\n    console.log('Card selection event:', event.detail);\n    \n    // Clear price data first to prevent reference errors\n    priceData = null;\n    \n    // Update the selected card state\n    selectedCard = event.detail;\n    cardName = selectedCard ? selectedCard.name : '';\n    \n    // Clear any previous error\n    error = null;\n    \n    // Validate the selection\n    if (selectedCard && !selectedCard.id) {\n      console.error('Selected card does not have an ID property:', selectedCard);\n      error = 'Invalid card data. Please select a different card.';\n    }\n  }\n  \n  // Functions for handling variant selection\n  function handleVariantSelect(event) {\n    selectedVariant = event.detail;\n  }\n  \n  function handleVariantConfirm(event) {\n    selectedVariant = event.detail;\n    loadPricingForVariant(selectedVariant);\n  }\n  \n  function closeVariantSelector() {\n    showVariantSelector = false;\n  }\n  \n  // Get the selected card ID\n  function getSelectedCardId() {\n    return selectedCard ? selectedCard.id : null;\n  }\n  \n  // Function to filter out zero or null price values with safety\n  function filterValidPrices(pricing) {\n    // Safety check for null/undefined input\n    if (!pricing || typeof pricing !== 'object') return {};\n    \n    // Create a new object with only valid price entries\n    const filteredPricing = {};\n    \n    try {\n      Object.entries(pricing).forEach(([market, priceInfo]) => {\n        // Skip null values entirely\n        if (priceInfo === null || priceInfo === undefined) return;\n        \n        // Handle different pricing formats\n        if (typeof priceInfo === 'object' && \n            priceInfo.value !== undefined && \n            priceInfo.value !== null && \n            parseFloat(priceInfo.value) > 0) {\n          // Object format with value property\n          filteredPricing[market] = priceInfo;\n        } else if (typeof priceInfo === 'number' && priceInfo > 0) {\n          // Direct number format\n          filteredPricing[market] = { value: priceInfo, currency: 'USD' };\n        } else if (typeof priceInfo === 'string' && parseFloat(priceInfo) > 0) {\n          // String that can be parsed as a number\n          filteredPricing[market] = { value: parseFloat(priceInfo), currency: 'USD' };\n        }\n      });\n    } catch (err) {\n      console.error('Error filtering prices:', err);\n      return {}; // Return empty object on error\n    }\n    \n    return filteredPricing;\n  }\n  \n  // Load pricing data for a specific variant\n  async function loadPricingForVariant(variant) {\n    try {\n      if (!variant || !variant.id) {\n        throw new Error('Invalid card variant');\n      }\n      \n      isLoading = true;\n      error = null;\n      \n      // Get pricing data for the selected variant\n      const rawPriceData = await pokeDataService.getCardPricing(variant.id);\n      \n      // Filter out zero or null price values\n      if (rawPriceData && rawPriceData.pricing) {\n        rawPriceData.pricing = filterValidPrices(rawPriceData.pricing);\n      }\n      \n      priceData = rawPriceData;\n      isLoading = false;\n    } catch (err) {\n      console.error('Error loading pricing for variant:', err);\n      error = err.message;\n      isLoading = false;\n      \n      // For development: Use mock data if API fails\n      try {\n        console.log('Attempting to load mock data for variant...');\n        const mockData = await pokeDataService.loadMockData(selectedSet.name, cardName);\n        \n        // Filter the mock data too\n        if (mockData && mockData.pricing) {\n          mockData.pricing = filterValidPrices(mockData.pricing);\n        }\n        \n        if (variant) {\n          // Update mock data to match the selected variant\n          mockData.name = variant.name;\n          mockData.num = variant.num;\n          if (variant.rarity) {\n            mockData.rarity = variant.rarity;\n          }\n        }\n        \n        priceData = mockData;\n        error = \"Using mock data (API unavailable). This is for demonstration purposes only.\";\n      } catch (mockErr) {\n        console.error('Failed to load mock data:', mockErr);\n      }\n    }\n  }\n\n  async function fetchCardPrice() {\n    if (!selectedSet) {\n      error = \"Please select a set\";\n      return;\n    }\n    \n    if (!selectedCard) {\n      error = \"Please select a card\";\n      return;\n    }\n    \n    isLoading = true;\n    error = null;\n    \n    try {\n      // Get the card ID from the selected card\n      const cardId = getSelectedCardId();\n      if (!cardId) {\n        throw new Error('Invalid card selection - missing ID');\n      }\n      \n      console.log(`Fetching price data for card ID: ${cardId}`);\n      \n      // Load pricing data directly using the card ID\n      const rawPriceData = await pokeDataService.getCardPricing(cardId);\n      \n      console.log('Received price data:', rawPriceData);\n      \n      // Filter out zero or null price values\n      if (rawPriceData && rawPriceData.pricing) {\n        rawPriceData.pricing = filterValidPrices(rawPriceData.pricing);\n        console.log('Filtered pricing data:', rawPriceData.pricing);\n      } else {\n        console.warn('No pricing data found in the response:', rawPriceData);\n      }\n      \n      priceData = rawPriceData;\n      \n    } catch (err) {\n      console.error('API Error:', err);\n      error = err.message;\n      \n      // For development: Use mock data if API fails\n      try {\n        console.log('Attempting to load mock data...');\n        const mockData = await pokeDataService.loadMockData(selectedSet.name, cardName);\n        \n        // Filter the mock data too\n        if (mockData && mockData.pricing) {\n          mockData.pricing = filterValidPrices(mockData.pricing);\n        }\n        \n        priceData = mockData;\n        error = \"Using mock data (API unavailable). This is for demonstration purposes only.\";\n      } catch (mockErr) {\n        console.error('Failed to load mock data:', mockErr);\n      }\n    } finally {\n      isLoading = false;\n    }\n  }\n\n  onMount(async () => {\n    try {\n      console.log('Initializing app and loading set list...');\n      // Get the set list with caching\n      const sets = await pokeDataService.getSetList();\n      console.log(`Loaded ${sets.length} sets`);\n      \n      // Verify all sets have an ID property\n      const setsWithoutIds = sets.filter(set => !set.id);\n      if (setsWithoutIds.length > 0) {\n        console.warn(`Found ${setsWithoutIds.length} sets without IDs`);\n        // Add IDs to the sets that don't have them\n        let maxId = Math.max(...sets.filter(set => set.id).map(set => set.id), 0);\n        setsWithoutIds.forEach(set => {\n          maxId++;\n          set.id = maxId;\n        });\n        console.log('Added IDs to sets that were missing them');\n      }\n      \n      // Check for any missing set codes\n      const setsWithoutCodes = sets.filter(set => !set.code);\n      if (setsWithoutCodes.length > 0) {\n        console.warn(`Found ${setsWithoutCodes.length} sets without codes`);\n      }\n      \n      availableSets = sets;\n    } catch (error) {\n      console.error('Error loading set list:', error);\n      // Fallback to imported data\n      console.log('Using fallback set list');\n      const { setList } = await import('./data/setList.js');\n      availableSets = setList;\n    }\n    \n    // Add debugging log to verify sets are loaded\n    console.log(`Available sets: ${availableSets.length}`);\n    if (availableSets.length > 0) {\n      console.log('First few sets:', availableSets.slice(0, 3));\n    }\n  });\n</script>\n\n<main>\n  <header>\n    <h1>Pokémon Card Price Checker</h1>\n  </header>\n  <div class=\"form-container\">\n    <div class=\"form-group\">\n      <label for=\"setSelect\">Select Set:</label>\n      <SearchableSelect\n        items={availableSets}\n        labelField=\"name\"\n        secondaryField=\"code\"\n        placeholder=\"Search for a set...\"\n        bind:value={selectedSet}\n        on:select={handleSetSelect}\n      />\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"cardName\">Card Name:</label>\n      \n      <!-- Replace the input field with SearchableSelect -->\n      {#if !selectedSet}\n        <div class=\"disabled-select\">\n          <input disabled placeholder=\"Select a set first\">\n        </div>\n      {:else if isLoadingCards}\n        <div class=\"loading-select\">\n          <input disabled placeholder=\"Loading cards...\">\n        </div>\n      {:else if cardsInSet.length === 0}\n        <div class=\"error-select\">\n          <input disabled placeholder=\"No cards found for this set\">\n        </div>\n      {:else}\n        <CardSearchSelect\n          bind:this={cardSearchComponent}\n          cards={cardsInSet}\n          bind:selectedCard={selectedCard}\n          on:select={handleCardSelect}\n        />\n      {/if}\n    </div>\n\n    <button on:click={fetchCardPrice} disabled={isLoading || !selectedCard}>\n      {isLoading ? 'Loading...' : 'Get Price'}\n    </button>\n\n    {#if error}\n      <p class=\"error\">{error}</p>\n    {/if}\n\n    <!-- Safely display results only if the price data exists -->\n    {#if priceData !== null && priceData !== undefined && typeof priceData === 'object'}\n      <div class=\"results\">\n        <!-- Always use safe property access to avoid null references -->\n        <h2>{priceData?.name || (selectedCard && selectedCard.name) || 'Card'}</h2>\n        <p><strong>Set:</strong> {priceData?.set_name || (selectedSet && selectedSet.name) || 'Unknown'}</p>\n        <p><strong>Number:</strong> {priceData?.num || (selectedCard && selectedCard.num) || 'Unknown'}</p>\n        \n        <!-- Only display rarity if we have it -->\n        {#if (priceData && priceData.rarity) || (selectedCard && selectedCard.rarity)}\n          <p><strong>Rarity:</strong> {(priceData && priceData.rarity) || (selectedCard && selectedCard.rarity) || 'Unknown'}</p>\n        {/if}\n        \n        <h3>Prices:</h3>\n        <!-- Check if we have any valid pricing data -->\n        {#if !priceData?.pricing || Object.keys(priceData.pricing || {}).length === 0}\n          <p class=\"no-prices\">No pricing data available for this card.</p>\n        {:else}\n          <ul>\n            {#each Object.entries(priceData.pricing || {}) as [market, price]}\n              <li>\n                <span class=\"market\">{market}:</span> \n                <span class=\"price\">${formatPrice(price?.value)}</span> \n                <span class=\"currency\">{price?.currency || 'USD'}</span>\n              </li>\n            {/each}\n          </ul>\n        {/if}\n      </div>\n    {/if}\n  </div>\n  \n\n  \n  <!-- Card Variant Selector Modal -->\n  <CardVariantSelector\n    variants={cardVariants}\n    isVisible={showVariantSelector}\n    on:select={handleVariantSelect}\n    on:confirm={handleVariantConfirm}\n    on:close={closeVariantSelector}\n  />\n</main>\n\n<style>\n  main {\n    max-width: 800px;\n    margin: 0 auto;\n    padding: 1rem;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n  }\n  \n  header {\n    background-color: #3c5aa6; /* Pokemon blue */\n    padding: 1rem;\n    border-radius: 8px 8px 0 0;\n    margin-bottom: 1.5rem;\n  }\n  \n  h1 {\n    color: white;\n    font-size: 1.8rem;\n    margin: 0;\n    text-align: center;\n    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);\n  }\n  \n  .form-container {\n    background-color: rgba(255, 255, 255, 0.9);\n    border-radius: 8px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\n    padding: 1.5rem;\n    margin-bottom: 1rem;\n    backdrop-filter: blur(5px);\n  }\n  \n  .form-group {\n    margin-bottom: 1rem;\n  }\n  \n  .form-group:last-of-type {\n    margin-bottom: 1.5rem;\n  }\n  \n  label {\n    display: block;\n    margin-bottom: 0.3rem;\n    font-weight: 500;\n  }\n  \n  input {\n    width: 100%;\n    padding: 0.6rem 0.75rem;\n    margin-bottom: 0.75rem;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 1rem;\n    transition: border-color 0.3s ease;\n  }\n  \n  input:focus {\n    outline: none;\n    border-color: #3c5aa6;\n    box-shadow: 0 0 0 2px rgba(60, 90, 166, 0.2);\n  }\n  \n  button {\n    width: 100%;\n    margin-top: 0.75rem;\n    padding: 0.75rem 1rem;\n    background-color: #ee1515; /* Pokemon red */\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 1rem;\n    font-weight: 600;\n    transition: background-color 0.3s ease;\n  }\n  \n  button:hover {\n    background-color: #cc0000;\n  }\n  \n  button:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n  \n  .disabled-select input, .loading-select input {\n    background-color: #f5f5f5;\n    color: #999;\n    cursor: not-allowed;\n  }\n  \n  .error-select input {\n    background-color: #fff8f8;\n    color: #cc0000;\n    cursor: not-allowed;\n    border: 1px solid #ffcccc;\n  }\n\n  \n\n  .error {\n    color: #ee1515;\n    font-size: 0.9rem;\n    margin-top: 0.5rem;\n    padding: 0.5rem;\n    background-color: rgba(238, 21, 21, 0.1);\n    border-radius: 4px;\n    text-align: center;\n  }\n  \n  .results {\n    margin-top: 1.5rem;\n    border: 1px solid #ddd;\n    border-radius: 8px;\n    padding: 1rem;\n    background-color: rgba(249, 249, 249, 0.9);\n    backdrop-filter: blur(5px);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n  }\n  \n  .results h2 {\n    color: #3c5aa6;\n    margin-top: 0;\n    border-bottom: 1px solid #ddd;\n    padding-bottom: 0.5rem;\n  }\n  \n  .results h3 {\n    margin-top: 1rem;\n    margin-bottom: 0.5rem;\n    color: #ee1515;\n  }\n  \n  .results ul {\n    list-style-type: none;\n    padding: 0;\n  }\n  \n  .results li {\n    padding: 0.5rem 0;\n    border-bottom: 1px solid #eee;\n  }\n  \n  .results li:last-child {\n    border-bottom: none;\n  }\n  \n  .market {\n    font-weight: 600;\n    text-transform: capitalize;\n  }\n  \n  .price {\n    font-weight: 700;\n    color: #ee1515;\n  }\n  \n  .currency {\n    color: #666;\n    font-size: 0.9rem;\n  }\n  \n  .no-prices {\n    color: #6c757d;\n    font-style: italic;\n    padding: 0.5rem 0;\n  }\n  \n  /* Responsive adjustments */\n  @media (max-width: 600px) {\n    main {\n      padding: 0.5rem;\n    }\n    \n    .form-container {\n      padding: 1rem;\n    }\n    \n    h1 {\n      font-size: 1.5rem;\n    }\n  }\n</style>","import App from './App.svelte';\n\nconst app = new App({\n  target: document.body\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","current_component","is_hydrating","upper_bound","low","high","key","value","mid","append","target","node","hydrate_init","children","childNodes","m","Int32Array","length","p","longest","i","seqLen","idx","claim_order","newLen","Math","max","lis","toMove","last","cur","push","reverse","sort","j","anchor","insertBefore","init_hydrate","undefined","actual_end_child","parentElement","firstChild","nextSibling","parentNode","appendChild","insert","detach","removeChild","destroy_each","iterations","detaching","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_input_value","input","set_current_component","component","get_current_component","Error","onMount","$$","on_mount","createEventDispatcher","type","detail","callbacks","e","createEvent","initCustomEvent","custom_event","slice","call","bubble","this","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","add_flush_callback","flushing","seen_callbacks","Set","flush","update","pop","callback","has","add","clear","fragment","before_update","dirty","ctx","after_update","outroing","outros","transition_in","block","local","delete","transition_out","o","c","bind","index","props","bound","create_component","mount_component","customElement","on_destroy","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","parent_component","on_disconnect","context","Map","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","l","intro","SvelteComponent","$destroy","$on","indexOf","splice","$set","$$props","obj","$$set","keys","API_CONFIG","baseUrl","apiKey","subscriptionKey","endpoints","pricing","sets","set","getHeaders","buildPricingUrl","id","encodeURIComponent","buildSetsUrl","buildCardsForSetUrl","setId","async","fetchWithProxy","url","console","log","headers","response","fetch","mode","ok","errorText","catch","error","status","statusText","DB_NAME","STORES","openDatabase","reject","request","indexedDB","open","onerror","onsuccess","result","onupgradeneeded","db","objectStoreNames","contains","createObjectStore","keyPath","dbService","saveSetList","setList","transaction","store","objectStore","put","timestamp","Date","now","oncomplete","getSetList","get","saveCardsForSet","setCode","cards","storageKey","getCardsForSet","saveCardPricing","cardId","pricingData","getCardPricing","hasCardsForSet","clearSetData","clearCardPricing","storeCardPricing","clearAllData","deleteDatabase","onblocked","warn","sortSetsByReleaseDate","dateA","release_date","ensureSetsHaveIds","isArray","highestId","pokeDataService","cachedSets","json","setsData","processedData","import","cachedCards","results","cachedPricing","loadMockData","setName","cardName","mockData","set_name","num","rarity","market","currency","tcgplayer","inputElement","dropdownElement","items","placeholder","labelField","secondaryField","searchText","showDropdown","filteredItems","highlightedIndex","dispatch","closeDropdown","scrollToHighlighted","highlightedEl","querySelector","scrollIntoView","handleItemSelect","item","getDisplayText","handleOutsideClick","matches","trim","searchLower","toLowerCase","primaryMatch","includes","secondaryMatch","preventDefault","min","focus","getCardDisplayText","card","selectedCard","filteredCards","handleSelect","clearSelection","search","nameMatch","numMatch","setTimeout","stopPropagation","variant","image_url","variants","isVisible","selectedVariant","selectVariant","close","entries","formatPrice","r","parseFloat","toFixed","filterValidPrices","filteredPricing","priceInfo","err","cardSearchComponent","selectedSet","priceData","isLoading","availableSets","cardsInSet","isLoadingCards","showVariantSelector","setsWithoutIds","maxId","setsWithoutCodes","code","prismaticEvolutionsCards","_","set_code","sampleCard","random","invalidCards","loadCardsForSet","rawPriceData","message","mockErr","loadPricingForVariant","app","body"],"mappings":"AAAA,SAASA,KAgBT,SAASC,EAAIC,GACT,OAAOA,GACX,CACA,SAASC,IACL,OAAOC,OAAOC,OAAO,KACzB,CACA,SAASC,EAAQC,GACbA,EAAIC,QAAQP,EAChB,CACA,SAASQ,EAAYC,GACjB,MAAwB,mBAAVA,CAClB,CACA,SAASC,EAAeC,EAAGC,GACvB,OAAOD,GAAKA,EAAIC,GAAKA,EAAID,IAAMC,GAAOD,GAAkB,iBAANA,GAAgC,mBAANA,CAChF,CAmKA,IAqmBIE,EArmBAC,GAAe,EAOnB,SAASC,EAAYC,EAAKC,EAAMC,EAAKC,GAEjC,KAAOH,EAAMC,GAAM,CACf,MAAMG,EAAMJ,GAAQC,EAAOD,GAAQ,GAC/BE,EAAIE,IAAQD,EACZH,EAAMI,EAAM,EAGZH,EAAOG,EAGf,OAAOJ,CACX,CAoEA,SAASK,EAAOC,EAAQC,GAChBT,IApER,SAAsBQ,GAClB,GAAIA,EAAOE,aACP,OACJF,EAAOE,cAAe,EAEtB,MAAMC,EAAWH,EAAOI,WAmBlBC,EAAI,IAAIC,WAAWH,EAASI,OAAS,GAErCC,EAAI,IAAIF,WAAWH,EAASI,QAClCF,EAAE,IAAM,EACR,IAAII,EAAU,EACd,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAASI,OAAQG,IAAK,CACtC,MAGMC,EAASlB,EAAY,EAAGgB,EAAU,GAAGG,GAAOT,EAASE,EAAEO,IAAMC,aAHnDV,EAASO,GAAGG,aAG+D,EAC3FL,EAAEE,GAAKL,EAAEM,GAAU,EACnB,MAAMG,EAASH,EAAS,EAExBN,EAAES,GAAUJ,EACZD,EAAUM,KAAKC,IAAIF,EAAQL,GAG/B,MAAMQ,EAAM,GAENC,EAAS,GACf,IAAIC,EAAOhB,EAASI,OAAS,EAC7B,IAAK,IAAIa,EAAMf,EAAEI,GAAW,EAAU,GAAPW,EAAUA,EAAMZ,EAAEY,EAAM,GAAI,CAEvD,IADAH,EAAII,KAAKlB,EAASiB,EAAM,IACjBD,GAAQC,EAAKD,IAChBD,EAAOG,KAAKlB,EAASgB,IAEzBA,IAEJ,KAAOA,GAAQ,EAAGA,IACdD,EAAOG,KAAKlB,EAASgB,IAEzBF,EAAIK,UAEJJ,EAAOK,MAAK,CAAClC,EAAGC,IAAMD,EAAEwB,YAAcvB,EAAEuB,cAExC,IAAK,IAAIH,EAAI,EAAGc,EAAI,EAAGd,EAAIQ,EAAOX,OAAQG,IAAK,CAC3C,KAAOc,EAAIP,EAAIV,QAAUW,EAAOR,GAAGG,aAAeI,EAAIO,GAAGX,aACrDW,IAEJ,MAAMC,EAASD,EAAIP,EAAIV,OAASU,EAAIO,GAAK,KACzCxB,EAAO0B,aAAaR,EAAOR,GAAIe,GAEvC,CAGQE,CAAa3B,SACoB4B,IAA5B5B,EAAO6B,kBAAiE,OAA5B7B,EAAO6B,kBAA+B7B,EAAO6B,iBAAiBC,gBAAkB9B,KAC7HA,EAAO6B,iBAAmB7B,EAAO+B,YAEjC9B,IAASD,EAAO6B,iBAChB7B,EAAO0B,aAAazB,EAAMD,EAAO6B,kBAGjC7B,EAAO6B,iBAAmB5B,EAAK+B,aAG9B/B,EAAKgC,aAAejC,GACzBA,EAAOkC,YAAYjC,EAE3B,CACA,SAASkC,EAAOnC,EAAQC,EAAMwB,GACtBjC,IAAiBiC,EACjB1B,EAAOC,EAAQC,IAEVA,EAAKgC,aAAejC,GAAWyB,GAAUxB,EAAK+B,cAAgBP,IACnEzB,EAAO0B,aAAazB,EAAMwB,GAAU,KAE5C,CACA,SAASW,EAAOnC,GACZA,EAAKgC,WAAWI,YAAYpC,EAChC,CACA,SAASqC,EAAaC,EAAYC,GAC9B,IAAK,IAAI9B,EAAI,EAAGA,EAAI6B,EAAWhC,OAAQG,GAAK,EACpC6B,EAAW7B,IACX6B,EAAW7B,GAAG+B,EAAED,EAE5B,CACA,SAASE,EAAQC,GACb,OAAOC,SAASC,cAAcF,EAClC,CAmBA,SAASG,EAAKC,GACV,OAAOH,SAASI,eAAeD,EACnC,CACA,SAASE,IACL,OAAOH,EAAK,IAChB,CACA,SAASI,IACL,OAAOJ,EAAK,GAChB,CACA,SAASK,EAAOlD,EAAMmD,EAAOC,EAASC,GAElC,OADArD,EAAKsD,iBAAiBH,EAAOC,EAASC,GAC/B,IAAMrD,EAAKuD,oBAAoBJ,EAAOC,EAASC,EAC1D,CAsBA,SAASG,EAAKxD,EAAMyD,EAAW7D,GACd,MAATA,EACAI,EAAK0D,gBAAgBD,GAChBzD,EAAK2D,aAAaF,KAAe7D,GACtCI,EAAK4D,aAAaH,EAAW7D,EACrC,CAkJA,SAASiE,EAAShB,EAAMC,GACpBA,EAAO,GAAKA,EACRD,EAAKiB,YAAchB,IACnBD,EAAKC,KAAOA,EACpB,CACA,SAASiB,EAAgBC,EAAOpE,GAC5BoE,EAAMpE,MAAiB,MAATA,EAAgB,GAAKA,CACvC,CAwRA,SAASqE,EAAsBC,GAC3B5E,EAAoB4E,CACxB,CACA,SAASC,IACL,IAAK7E,EACD,MAAM,IAAI8E,MAAM,oDACpB,OAAO9E,CACX,CAIA,SAAS+E,EAAQ3F,GACbyF,IAAwBG,GAAGC,SAASnD,KAAK1C,EAC7C,CAOA,SAAS8F,IACL,MAAMN,EAAYC,IAClB,MAAO,CAACM,EAAMC,KACV,MAAMC,EAAYT,EAAUI,GAAGK,UAAUF,GACzC,GAAIE,EAAW,CAGX,MAAMxB,EAzNlB,SAAsBsB,EAAMC,GACxB,MAAME,EAAIjC,SAASkC,YAAY,eAE/B,OADAD,EAAEE,gBAAgBL,GAAM,GAAO,EAAOC,GAC/BE,CACX,CAqN0BG,CAAaN,EAAMC,GACjCC,EAAUK,QAAQhG,SAAQN,IACtBA,EAAGuG,KAAKf,EAAWf,EAAM,KAIzC,CAaA,SAAS+B,EAAOhB,EAAWf,GACvB,MAAMwB,EAAYT,EAAUI,GAAGK,UAAUxB,EAAMsB,MAC3CE,GAEAA,EAAUK,QAAQhG,SAAQN,GAAMA,EAAGuG,KAAKE,KAAMhC,IAEtD,CAEA,MAAMiC,EAAmB,GAEnBC,EAAoB,GACpBC,EAAmB,GACnBC,EAAkB,GAClBC,EAAmBC,QAAQC,UACjC,IAAIC,GAAmB,EAWvB,SAASC,EAAoBlH,GACzB4G,EAAiBlE,KAAK1C,EAC1B,CACA,SAASmH,EAAmBnH,GACxB6G,EAAgBnE,KAAK1C,EACzB,CACA,IAAIoH,GAAW,EACf,MAAMC,EAAiB,IAAIC,IAC3B,SAASC,IACL,IAAIH,EAAJ,CAEAA,GAAW,EACX,EAAG,CAGC,IAAK,IAAIrF,EAAI,EAAGA,EAAI2E,EAAiB9E,OAAQG,GAAK,EAAG,CACjD,MAAMyD,EAAYkB,EAAiB3E,GACnCwD,EAAsBC,GACtBgC,EAAOhC,EAAUI,IAIrB,IAFAL,EAAsB,MACtBmB,EAAiB9E,OAAS,EACnB+E,EAAkB/E,QACrB+E,EAAkBc,KAAlBd,GAIJ,IAAK,IAAI5E,EAAI,EAAGA,EAAI6E,EAAiBhF,OAAQG,GAAK,EAAG,CACjD,MAAM2F,EAAWd,EAAiB7E,GAC7BsF,EAAeM,IAAID,KAEpBL,EAAeO,IAAIF,GACnBA,KAGRd,EAAiBhF,OAAS,QACrB8E,EAAiB9E,QAC1B,KAAOiF,EAAgBjF,QACnBiF,EAAgBY,KAAhBZ,GAEJI,GAAmB,EACnBG,GAAW,EACXC,EAAeQ,QACnB,CACA,SAASL,EAAO5B,GACZ,GAAoB,OAAhBA,EAAGkC,SAAmB,CACtBlC,EAAG4B,SACHpH,EAAQwF,EAAGmC,eACX,MAAMC,EAAQpC,EAAGoC,MACjBpC,EAAGoC,MAAQ,EAAE,GACbpC,EAAGkC,UAAYlC,EAAGkC,SAASjG,EAAE+D,EAAGqC,IAAKD,GACrCpC,EAAGsC,aAAa5H,QAAQ4G,GAEhC,CAeA,MAAMiB,EAAW,IAAIb,IACrB,IAAIc,EAcJ,SAASC,EAAcC,EAAOC,GACtBD,GAASA,EAAMvG,IACfoG,EAASK,OAAOF,GAChBA,EAAMvG,EAAEwG,GAEhB,CACA,SAASE,EAAeH,EAAOC,EAAO9E,EAAQiE,GAC1C,GAAIY,GAASA,EAAMI,EAAG,CAClB,GAAIP,EAASR,IAAIW,GACb,OACJH,EAASP,IAAIU,GACbF,EAAOO,EAAEjG,MAAK,KACVyF,EAASK,OAAOF,GACZZ,IACIjE,GACA6E,EAAMxE,EAAE,GACZ4D,QAGRY,EAAMI,EAAEH,GAEhB,CAwlBA,SAASK,EAAKpD,EAAWxB,EAAM0D,GAC3B,MAAMmB,EAAQrD,EAAUI,GAAGkD,MAAM9E,QACnBf,IAAV4F,IACArD,EAAUI,GAAGmD,MAAMF,GAASnB,EAC5BA,EAASlC,EAAUI,GAAGqC,IAAIY,IAElC,CACA,SAASG,EAAiBV,GACtBA,GAASA,EAAMK,GACnB,CAIA,SAASM,EAAgBzD,EAAWnE,EAAQyB,EAAQoG,GAChD,MAAMpB,SAAEA,EAAQjC,SAAEA,EAAQsD,WAAEA,EAAUjB,aAAEA,GAAiB1C,EAAUI,GACnEkC,GAAYA,EAASpG,EAAEL,EAAQyB,GAC1BoG,GAEDhC,GAAoB,KAChB,MAAMkC,EAAiBvD,EAASwD,IAAItJ,GAAKuJ,OAAO/I,GAC5C4I,EACAA,EAAWzG,QAAQ0G,GAKnBhJ,EAAQgJ,GAEZ5D,EAAUI,GAAGC,SAAW,EAAE,IAGlCqC,EAAa5H,QAAQ4G,EACzB,CACA,SAASqC,EAAkB/D,EAAW3B,GAClC,MAAM+B,EAAKJ,EAAUI,GACD,OAAhBA,EAAGkC,WACH1H,EAAQwF,EAAGuD,YACXvD,EAAGkC,UAAYlC,EAAGkC,SAAShE,EAAED,GAG7B+B,EAAGuD,WAAavD,EAAGkC,SAAW,KAC9BlC,EAAGqC,IAAM,GAEjB,CACA,SAASuB,EAAWhE,EAAWzD,IACI,IAA3ByD,EAAUI,GAAGoC,MAAM,KACnBtB,EAAiBhE,KAAK8C,GAvvBrByB,IACDA,GAAmB,EACnBH,EAAiB2C,KAAKlC,IAuvBtB/B,EAAUI,GAAGoC,MAAM0B,KAAK,IAE5BlE,EAAUI,GAAGoC,MAAOjG,EAAI,GAAM,IAAO,GAAMA,EAAI,EACnD,CACA,SAAS4H,EAAKnE,EAAWb,EAASiF,EAAUC,EAAiBC,EAAWhB,EAAOd,EAAQ,EAAE,IACrF,MAAM+B,EAAmBnJ,EACzB2E,EAAsBC,GACtB,MAAMI,EAAKJ,EAAUI,GAAK,CACtBkC,SAAU,KACVG,IAAK,KAELa,QACAtB,OAAQ1H,EACRgK,YACAf,MAAO9I,IAEP4F,SAAU,GACVsD,WAAY,GACZa,cAAe,GACfjC,cAAe,GACfG,aAAc,GACd+B,QAAS,IAAIC,IAAIH,EAAmBA,EAAiBnE,GAAGqE,QAAUtF,EAAQsF,SAAW,IAErFhE,UAAWhG,IACX+H,QACAmC,YAAY,GAEhB,IAAIC,GAAQ,EAkBZ,GAjBAxE,EAAGqC,IAAM2B,EACHA,EAASpE,EAAWb,EAAQmE,OAAS,IAAI,CAAC/G,EAAGsI,KAAQC,KACnD,MAAMpJ,EAAQoJ,EAAK1I,OAAS0I,EAAK,GAAKD,EAOtC,OANIzE,EAAGqC,KAAO6B,EAAUlE,EAAGqC,IAAIlG,GAAI6D,EAAGqC,IAAIlG,GAAKb,MACtC0E,EAAGuE,YAAcvE,EAAGmD,MAAMhH,IAC3B6D,EAAGmD,MAAMhH,GAAGb,GACZkJ,GACAZ,EAAWhE,EAAWzD,IAEvBsI,CAAG,IAEZ,GACNzE,EAAG4B,SACH4C,GAAQ,EACRhK,EAAQwF,EAAGmC,eAEXnC,EAAGkC,WAAW+B,GAAkBA,EAAgBjE,EAAGqC,KAC/CtD,EAAQtD,OAAQ,CAChB,GAAIsD,EAAQ4F,QAAS,CAz8CzB1J,GAAe,EA28CP,MAAM2J,EA7tClB,SAAkBzG,GACd,OAAO0G,MAAMC,KAAK3G,EAAQtC,WAC9B,CA2tC0BD,CAASmD,EAAQtD,QAE/BuE,EAAGkC,UAAYlC,EAAGkC,SAAS6C,EAAEH,GAC7BA,EAAMlK,QAAQmD,QAIdmC,EAAGkC,UAAYlC,EAAGkC,SAASa,IAE3BhE,EAAQiG,OACRvC,EAAc7C,EAAUI,GAAGkC,UAC/BmB,EAAgBzD,EAAWb,EAAQtD,OAAQsD,EAAQ7B,OAAQ6B,EAAQuE,eAn9CvErI,GAAe,EAq9CX0G,IAEJhC,EAAsBwE,EAC1B,CAiDA,MAAMc,EACF,QAAAC,GACIvB,EAAkB9C,KAAM,GACxBA,KAAKqE,SAAWhL,EAEpB,GAAAiL,CAAIhF,EAAM2B,GACN,MAAMzB,EAAaQ,KAAKb,GAAGK,UAAUF,KAAUU,KAAKb,GAAGK,UAAUF,GAAQ,IAEzE,OADAE,EAAUvD,KAAKgF,GACR,KACH,MAAMmB,EAAQ5C,EAAU+E,QAAQtD,IACjB,IAAXmB,GACA5C,EAAUgF,OAAOpC,EAAO,EAAE,EAGtC,IAAAqC,CAAKC,GA3rDT,IAAkBC,EA4rDN3E,KAAK4E,QA5rDCD,EA4rDkBD,EA3rDG,IAA5BjL,OAAOoL,KAAKF,GAAKxJ,UA4rDhB6E,KAAKb,GAAGuE,YAAa,EACrB1D,KAAK4E,MAAMF,GACX1E,KAAKb,GAAGuE,YAAa,IChuD1B,MAAMoB,EAAa,CAExBC,QAAS,wDAGTC,OAAQ,4TAGRC,gBAAiB,mCAGjBC,UAAW,CACTC,QAAS,WACTC,KAAM,QACNC,IAAK,QAIPC,WAAU,KACD,CAGL,eAAgB,qBAKpB,eAAAC,CAAgBC,GACd,MAAO,GAAGxF,KAAK+E,UAAU/E,KAAKkF,UAAUC,cAAcM,mBAAmBD,sBAG3E,YAAAE,GACE,MAAO,GAAG1F,KAAK+E,UAAU/E,KAAKkF,UAAUE,QAG1C,mBAAAO,CAAoBC,GAClB,MAAO,GAAG5F,KAAK+E,UAAU/E,KAAKkF,UAAUG,cAAcI,mBAAmBG,OCpCtEC,eAAeC,EAAeC,EAAK7H,EAAU,IAElD,IACE8H,QAAQC,IAAI,kBAAkBF,KAC9BC,QAAQC,IAAI,iBAAkB/H,EAAQgI,SAEtC,MAAMC,QAAiBC,MAAML,EAAK,IAC7B7H,EACHmI,KAAM,SAGR,IAAKF,EAASG,GAAI,CAChB,MAAMC,QAAkBJ,EAASzI,OAAO8I,OAAM,IAAM,gCAEpD,MADAR,QAAQS,MAAM,eAAeN,EAASO,YAAYP,EAASQ,oBAAoBZ,eAAiBQ,KAC1F,IAAItH,MAAM,uBAAuBkH,EAASO,YAAYP,EAASQ,cAGvE,OAAOR,EACP,MAAOM,GAEP,MADAT,QAAQS,MAAM,wBAAwBV,MAASU,GACzCA,EAEV,CCjBA,MAAMG,EAAU,eAEVC,EACK,UADLA,EAEQ,aAFRA,GAGS,cAOFC,GAAe,IACnB,IAAIxG,SAAQ,CAACC,EAASwG,KAC3B,MAAMC,EAAUC,UAAUC,KAAKN,EAbhB,GAefI,EAAQG,QAAWnJ,IACjBgI,QAAQS,MAAM,0BAA2BzI,EAAMpD,OAAO6L,OACtDM,EAAO/I,EAAMpD,OAAO6L,MAAM,EAG5BO,EAAQI,UAAapJ,IACnBuC,EAAQvC,EAAMpD,OAAOyM,OAAO,EAG9BL,EAAQM,gBAAmBtJ,IACzB,MAAMuJ,EAAKvJ,EAAMpD,OAAOyM,OAGnBE,EAAGC,iBAAiBC,SAASZ,IAChCU,EAAGG,kBAAkBb,EAAgB,CAAEc,QAAS,OAG7CJ,EAAGC,iBAAiBC,SAASZ,IAChCU,EAAGG,kBAAkBb,EAAmB,CAAEc,QAAS,YAIhDJ,EAAGC,iBAAiBC,SAASZ,KAChCU,EAAGG,kBAAkBb,GAAoB,CAAEc,QAAS,OAEvD,IAOQC,GAAY,CAMvB,iBAAMC,CAAYC,GAChB,IACE,MACMC,SADWjB,MACMiB,YAAYlB,EAAgB,aAC7CmB,EAAQD,EAAYE,YAAYpB,GAStC,aANMmB,EAAME,IAAI,CACd1C,GAAI,cACJ7H,KAAMmK,EACNK,UAAWC,KAAKC,QAGX,IAAI/H,SAAQ,CAACC,EAASwG,KAC3BgB,EAAYO,WAAa,IAAM/H,IAC/BwH,EAAYZ,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAE7D,MAAOA,GAEP,MADAT,QAAQS,MAAM,yBAA0BA,GAClCA,IAQV,gBAAM8B,GACJ,IACE,MACMR,SADWjB,MACMiB,YAAYlB,EAAgB,YAG7CG,EAFQe,EAAYE,YAAYpB,GAEhB2B,IAAI,eAE1B,OAAO,IAAIlI,SAAQ,CAACC,EAASwG,KAC3BC,EAAQI,UAAY,KAEdJ,EAAQK,QAAUL,EAAQK,OAAO1J,KACnC4C,EAAQyG,EAAQK,OAAO1J,MAGvB4C,EAAQ,OAIZyG,EAAQG,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAEzD,MAAOA,GAEP,MADAT,QAAQS,MAAM,0BAA2BA,GACnCA,IAUV,qBAAMgC,CAAgBC,EAASC,GAC7B,IAEE,MAAMC,EAAaF,GAAW,cAGxBX,SADWjB,MACMiB,YAAYlB,EAAmB,aAChDmB,EAAQD,EAAYE,YAAYpB,GAQtC,aANMmB,EAAME,IAAI,CACdQ,QAASE,EACTD,QACAR,UAAWC,KAAKC,QAGX,IAAI/H,SAAQ,CAACC,EAASwG,KAC3BgB,EAAYO,WAAa,IAAM/H,IAC/BwH,EAAYZ,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAE7D,MAAOA,GAEP,MADAT,QAAQS,MAAM,8BAA8BiC,KAAYjC,GAClDA,IASV,oBAAMoC,CAAeH,GACnB,IAEE,MAAME,EAAaF,GAAW,cAGxBX,SADWjB,MACMiB,YAAYlB,EAAmB,YAGhDG,EAFQe,EAAYE,YAAYpB,GAEhB2B,IAAII,GAE1B,OAAO,IAAItI,SAAQ,CAACC,EAASwG,KAC3BC,EAAQI,UAAY,KAEdJ,EAAQK,QAAUL,EAAQK,OAAOsB,MACnCpI,EAAQyG,EAAQK,OAAOsB,OAGvBpI,EAAQ,OAIZyG,EAAQG,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAEzD,MAAOA,GAEP,MADAT,QAAQS,MAAM,+BAA+BiC,KAAYjC,GACnDA,IAUV,qBAAMqC,CAAgBC,EAAQC,GAC5B,IACE,MACMjB,SADWjB,MACMiB,YAAYlB,GAAoB,aACjDmB,EAAQD,EAAYE,YAAYpB,IAQtC,aANMmB,EAAME,IAAI,CACd1C,GAAIuD,EACJpL,KAAMqL,EACNb,UAAWC,KAAKC,QAGX,IAAI/H,SAAQ,CAACC,EAASwG,KAC3BgB,EAAYO,WAAa,IAAM/H,IAC/BwH,EAAYZ,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAE7D,MAAOA,GAEP,MADAT,QAAQS,MAAM,sCAAsCsC,KAAWtC,GACzDA,IASV,oBAAMwC,CAAeF,GACnB,IACE,MACMhB,SADWjB,MACMiB,YAAYlB,GAAoB,YAGjDG,EAFQe,EAAYE,YAAYpB,IAEhB2B,IAAIO,GAE1B,OAAO,IAAIzI,SAAQ,CAACC,EAASwG,KAC3BC,EAAQI,UAAY,KAEdJ,EAAQK,QAAUL,EAAQK,OAAO1J,KACnC4C,EAAQyG,EAAQK,OAAO1J,MAGvB4C,EAAQ,OAIZyG,EAAQG,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAEzD,MAAOA,GAEP,MADAT,QAAQS,MAAM,uCAAuCsC,KAAWtC,GAC1DA,IASV,oBAAMyC,CAAeR,GACnB,IAEE,MAAME,EAAaF,GAAW,cAG9B,OAAiB,aADG1I,KAAK6I,eAAeD,GAExC,MAAOnC,GAEP,OADAT,QAAQS,MAAM,2CAA2CiC,KAAYjC,IAC9D,IASX,kBAAM0C,CAAaT,GACjB,IAEE,MAAME,EAAaF,GAAW,cAGxBX,SADWjB,MACMiB,YAAYlB,EAAmB,aAGhDG,EAFQe,EAAYE,YAAYpB,GAEhB9E,OAAO6G,GAE7B,OAAO,IAAItI,SAAQ,CAACC,EAASwG,KAC3BC,EAAQI,UAAY,KAClBpB,QAAQC,IAAI,yBAAyByC,KACrCnI,GAAS,EAEXyG,EAAQG,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAEzD,MAAOA,GAEP,MADAT,QAAQS,MAAM,+BAA+BiC,KAAYjC,GACnDA,IASV,sBAAM2C,CAAiBL,GACrB,IACE,MACMhB,SADWjB,MACMiB,YAAYlB,GAAoB,aAGjDG,EAFQe,EAAYE,YAAYpB,IAEhB9E,OAAOgH,GAE7B,OAAO,IAAIzI,SAAQ,CAACC,EAASwG,KAC3BC,EAAQI,UAAY,KAClBpB,QAAQC,IAAI,kCAAkC8C,KAC9CxI,GAAS,EAEXyG,EAAQG,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAEzD,MAAOA,GAEP,MADAT,QAAQS,MAAM,wCAAwCsC,KAAWtC,GAC3DA,IAQV,sBAAM4C,CAAiBN,EAAQC,GAC7B,IACE,MACMjB,SADWjB,MACMiB,YAAYlB,GAAoB,aACjDmB,EAAQD,EAAYE,YAAYpB,IAQtC,aANMmB,EAAME,IAAI,CACd1C,GAAIuD,EACJpL,KAAMqL,EACNb,UAAWC,KAAKC,QAGX,IAAI/H,SAAQ,CAACC,EAASwG,KAC3BgB,EAAYO,WAAa,IAAM/H,IAC/BwH,EAAYZ,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAE7D,MAAOA,GAEP,MADAT,QAAQS,MAAM,kCAAkCsC,KAAWtC,GACrDA,IASV,oBAAMwC,CAAeF,GACnB,IACE,MACMhB,SADWjB,MACMiB,YAAYlB,GAAoB,YAGjDG,EAFQe,EAAYE,YAAYpB,IAEhB2B,IAAIO,GAE1B,OAAO,IAAIzI,SAAQ,CAACC,EAASwG,KAC3BC,EAAQI,UAAY,KAEdJ,EAAQK,QAAUL,EAAQK,OAAO1J,KACnC4C,EAAQyG,EAAQK,OAAO1J,MAGvB4C,EAAQ,OAIZyG,EAAQG,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAEzD,MAAOA,GAEP,MADAT,QAAQS,MAAM,kCAAkCsC,KAAWtC,GACrDA,IAIV,kBAAM6C,GACJ,IACE,MACMvB,SADWjB,MACMiB,YAAY,CAAClB,EAAgBA,EAAmBA,IAAqB,aAM5F,OAJAkB,EAAYE,YAAYpB,GAAgBzF,QACxC2G,EAAYE,YAAYpB,GAAmBzF,QAC3C2G,EAAYE,YAAYpB,IAAoBzF,QAErC,IAAId,SAAQ,CAACC,EAASwG,KAC3BgB,EAAYO,WAAa,KACvBtC,QAAQC,IAAI,uCACZ1F,GAAS,EAEXwH,EAAYZ,QAAWnJ,GAAU+I,EAAO/I,EAAMpD,OAAO6L,MAAM,IAE7D,MAAOA,GAEP,MADAT,QAAQS,MAAM,2BAA4BA,GACpCA,IAQVZ,cAAmB,SACV,IAAIvF,SAAQ,CAACC,EAASwG,KAC3B,MAAMC,EAAUC,UAAUsC,eAAe3C,GAEzCI,EAAQI,UAAY,KAClBpB,QAAQC,IAAI,YAAYW,0BACxBrG,GAAS,EAGXyG,EAAQG,QAAWnJ,IACjBgI,QAAQS,MAAM,2BAA4BzI,EAAMpD,OAAO6L,OACvDM,EAAO/I,EAAMpD,OAAO6L,MAAM,EAG5BO,EAAQwC,UAAY,KAClBxD,QAAQyD,KAAK,yDAEblJ,GAAS,CACV,KCtZP,SAASmJ,GAAsBtE,GAC7B,OAAOA,EAAKjJ,MAAK,CAAClC,EAAGC,KAEnB,MAAMyP,EAAQ,IAAIvB,KAAKnO,EAAE2P,cAAgB,GAEzC,OADc,IAAIxB,KAAKlO,EAAE0P,cAAgB,GAC1BD,CAAK,GAExB,CAOA,SAASE,GAAkBzE,GACzB,IAAKA,IAASpB,MAAM8F,QAAQ1E,GAAO,MAAO,GAE1C,IAAI2E,EAAY,EAUhB,OAPA3E,EAAKvL,SAAQwL,IACPA,EAAIG,IAAwB,iBAAXH,EAAIG,IAAmBH,EAAIG,GAAKuE,IACnDA,EAAY1E,EAAIG,OAKbJ,EAAKxC,KAAIyC,GAEVA,EAAIG,GAAWH,GAGnB0E,GAAa,EACN,IAAK1E,EAAKG,GAAIuE,KAEzB,CAKO,MAAMC,GAAkB,CAK7B,gBAAMzB,GACJ,IACEvC,QAAQC,IAAI,wBAEZ,MAAMgE,QAAmBrC,GAAUW,aACnC,GAAI0B,GAAcA,EAAW9O,OAAS,EAEpC,OADA6K,QAAQC,IAAI,4BAA4BgE,EAAW9O,eAC5CuO,GAAsBG,GAAkBI,IAIjD,MAAMlE,EAAMjB,EAAWY,eACvBM,QAAQC,IAAI,2BAA2BF,KAEvC,MAAMI,QAAiBL,EAAeC,EAAK,CACzCG,QAASpB,EAAWQ,eAGtB,IAAKa,EAASG,GAAI,CAChB,MAAMC,QAAkBJ,EAASzI,OAAO8I,OAAM,IAAM,gCAEpD,MADAR,QAAQS,MAAM,cAAcN,EAASO,YAAYH,KAC3C,IAAItH,MAAM,cAAckH,EAASO,oBAAoBH,KAG7D,MAAM5I,QAAawI,EAAS+D,OAC5BlE,QAAQC,IAAI,yBAA0BtI,GAGtC,IAAIwM,EAAWxM,GAGVqG,MAAM8F,QAAQnM,IAASA,EAAKA,MAAQqG,MAAM8F,QAAQnM,EAAKA,QAC1DqI,QAAQC,IAAI,uCACZkE,EAAWxM,EAAKA,OAIbqG,MAAM8F,QAAQnM,IAASA,EAAKyH,MAAQpB,MAAM8F,QAAQnM,EAAKyH,QAC1DY,QAAQC,IAAI,kCACZkE,EAAWxM,EAAKyH,MAIlB,MAAMgF,EAAgBP,GAAkBM,GAQxC,OAPAnE,QAAQC,IAAI,aAAamE,EAAcjP,wBAGnCiP,GAAiBpG,MAAM8F,QAAQM,UAC3BxC,GAAUC,YAAYuC,GAGvBV,GAAsBU,GAC7B,MAAO3D,GACPT,QAAQS,MAAM,uBAAwBA,GAEtCT,QAAQC,IAAI,uDACZ,MAAM6B,QAAEA,SAAkBuC,OAAO,yBACjC,OAAOX,GAAsB5B,KAUjC,oBAAMe,CAAeH,EAAS9C,GAC5B,IACE,IAAKA,EAEH,OADAI,QAAQS,MAAM,qCACP,GAIJiC,IACH1C,QAAQyD,KAAK,+DAEbf,EAAU,MAAM9C,KAIlB,MAAM0E,QAAoB1C,GAAUiB,eAAeH,GACnD,GAAI4B,GAAeA,EAAYnP,OAAS,EAEtC,OADA6K,QAAQC,IAAI,8BAA8ByC,MAAY4B,EAAYnP,gBAC3DmP,EAGTtE,QAAQC,IAAI,0BAA0ByC,UAAgB9C,kBAGtD,MAAMG,EAAMjB,EAAWa,oBAAoBC,GAC3CI,QAAQC,IAAI,sBAAsBF,KAElC,MAAMI,QAAiBL,EAAeC,EAAK,CACzCG,QAASpB,EAAWQ,eAGtB,IAAKa,EAASG,GAAI,CAChB,MAAMC,QAAkBJ,EAASzI,OAAO8I,OAAM,IAAM,gCAEpD,MADAR,QAAQS,MAAM,qBAAqBiC,MAAYvC,EAASO,YAAYH,KAC9D,IAAItH,MAAM,cAAckH,EAASO,oBAAoBH,KAG7D,MAAM5I,QAAawI,EAAS+D,OAC5BlE,QAAQC,IAAI,wBAAwByC,KAAY/K,GAGhD,IAAIgL,EAAQ,GAGZ,GAAIhL,GAAQA,EAAKgL,OAAS3E,MAAM8F,QAAQnM,EAAKgL,OAC3C3C,QAAQC,IAAI,0BAA0BtI,EAAKgL,MAAMxN,gBACjDwN,EAAQhL,EAAKgL,WAGV,GAAIhL,GAAQqG,MAAM8F,QAAQnM,GAC7BqI,QAAQC,IAAI,mCAAmCtI,EAAKxC,gBACpDwN,EAAQhL,OAGL,GAAIA,GAAQA,EAAKA,MAAQqG,MAAM8F,QAAQnM,EAAKA,MAC/CqI,QAAQC,IAAI,kCAAkCtI,EAAKA,KAAKxC,gBACxDwN,EAAQhL,EAAKA,UAGV,GAAIA,GAAQA,EAAK4M,SAAWvG,MAAM8F,QAAQnM,EAAK4M,SAClDvE,QAAQC,IAAI,qCAAqCtI,EAAK4M,QAAQpP,gBAC9DwN,EAAQhL,EAAK4M,YAEV,CACHvE,QAAQyD,KAAK,0BAA2B9L,GAExC,IAAK,MAAMnD,KAAOmD,EAChB,GAAIqG,MAAM8F,QAAQnM,EAAKnD,KAASmD,EAAKnD,GAAKW,OAAS,EAAG,CACpD6K,QAAQC,IAAI,4CAA4CzL,WAAamD,EAAKnD,GAAKW,gBAC/EwN,EAAQhL,EAAKnD,GACb,OAkBN,OAZImO,EAAMxN,OAAS,GACjB6K,QAAQC,IAAI,qBAAsB0C,EAAM,IAI1C3C,QAAQC,IAAI,SAAS0C,EAAMxN,wBAAwBuN,KAG/CC,EAAMxN,OAAS,SACXyM,GAAUa,gBAAgBC,EAASC,GAGpCA,EACP,MAAOlC,GAEP,OADAT,QAAQS,MAAM,gCAAgCiC,KAAYjC,GACnD,KASX,oBAAMwC,CAAeF,GACnB,IACE,IAAKA,EACH,MAAM,IAAI9J,MAAM,6CAGlB+G,QAAQC,IAAI,qCAAqC8C,KAGjD,MAAMyB,QAAsB5C,GAAUqB,eAAeF,GACrD,GAAIyB,EAEF,OADAxE,QAAQC,IAAI,iCAAiC8C,KACtCyB,EAIT,MAAMzE,EAAMjB,EAAWS,gBAAgBwD,GACvC/C,QAAQC,IAAI,wBAAwBF,KAEpC,MAAMI,QAAiBL,EAAeC,EAAK,CACzCG,QAASpB,EAAWQ,eAGtB,IAAKa,EAASG,GAAI,CAChB,MAAMC,QAAkBJ,EAASzI,OAAO8I,OAAM,IAAM,gCAEpD,MADAR,QAAQS,MAAM,yBAAyBsC,MAAW5C,EAASO,YAAYH,KACjE,IAAItH,MAAM,cAAckH,EAASO,oBAAoBH,KAG7D,MAAM5I,QAAawI,EAAS+D,OAC5BlE,QAAQC,IAAI,iCAAiC8C,KAAWpL,GAGxD,IAAIqL,EAAcrL,EAalB,OAVIA,GAAQA,EAAKA,MAA6B,iBAAdA,EAAKA,OACnCqI,QAAQC,IAAI,0CACZ+C,EAAcrL,EAAKA,MAIjBqL,SACIpB,GAAUkB,gBAAgBC,EAAQC,GAGnCA,EACP,MAAOvC,GAEP,MADAT,QAAQS,MAAM,mCAAmCsC,KAAWtC,GACtDA,IAUV,kBAAMgE,CAAaC,EAASC,GAC1B,IACE,MAAMxE,QAAiBC,MAAM,gCACvBwE,QAAiBzE,EAAS+D,OAMhC,OAHAU,EAASrN,KAAOoN,GAAY,YAC5BC,EAASC,SAAWH,GAAW,WAExBE,EACP,MAAOnE,GAIP,OAHAT,QAAQS,MAAM,2BAA4BA,GAGnC,CACLjB,GAAI,UACJjI,KAAMoN,GAAY,YAClBE,SAAUH,GAAW,WACrBI,IAAK,QACLC,OAAQ,YACR5F,QAAS,CACP6F,OAAU,CAAEvQ,MAAO,OAAQwQ,SAAU,OACrCC,UAAa,CAAEzQ,MAAO,OAAQwQ,SAAU,yHCzHd,IAAzBzJ,KAAcrG,yQAGVqG,0BAALrG,6KAAKqG,aAALrG,uIAAAA,sNASgCqG,MAAKA,4JAALA,MAAKA,uEAFhCA,MAAKA,WACDA,MAAkBA,MAAKA,4MANZA,WAAQA,OAAqBA,MAAQ,cAAgB,4JAKpEA,MAAKA,kBACDA,MAAkBA,MAAKA,2FANZA,WAAQA,OAAqBA,MAAQ,cAAgB,iHAVlDA,KAAe,IAAM,MAG/CA,uIANYA,kPAJDA,uFACFA,mBACAA,oBACEA,+CACCA,qBAJDA,UAAAA,mBAOeA,KAAe,IAAM,aAG/CA,6IApKD2J,EACAC,SAZOC,qBACAC,EAAc,2BACdC,EAAa,0BACbC,EAAiB,eACjB/Q,EAAQ,QAGfgR,EAAa,GACbC,GAAe,EACfC,KACAC,GAAoB,QAIlBC,EAAWxM,aA2CRyM,QACPJ,GAAe,YA4BRK,OACHH,GAAoB,GAAKR,SACrBY,EAAgBZ,EAAgBa,uBAAuBL,KACzDI,GACFA,EAAcE,gBAAiBrK,MAAO,sBAKnCsK,EAAiBC,GACnBA,SAGL3R,EAAQ2R,OACRX,EAAaY,EAAeD,IAG5BN,IAGAD,EAAS,SAAUO,aAGZC,EAAeD,UACjBA,EACDZ,GAAkBY,EAAKZ,MACfY,EAAKb,OAAgBa,EAAKZ,MAE/BY,EAAKb,GAJM,YAmCXe,EAAmBtO,GACtB0N,GAAgBP,IAAiBC,EAAgB3D,SAASzJ,EAAMpD,UAAYuQ,EAAa1D,SAASzJ,EAAMpD,SAC1GkR,IAKJ5M,QACE1B,SAASW,iBAAiB,QAASmO,QAEjC9O,SAASY,oBAAoB,QAASkO,sPA1InC7R,IACA0Q,GAAiBA,EAAaoB,QAAQ,eACzCd,EAAaY,EAAe5R,0BAM9BuL,QAAQC,IAAI,mCAAoCwF,GAE5CJ,GAASrH,MAAM8F,QAAQuB,QAErBI,GAAoC,KAAtBA,EAAWe,QAAmB/R,GAASgR,IAAeY,EAAe5R,OAWrFkR,MAAoBN,eAVdoB,EAAchB,EAAWiB,kBAC/Bf,EAAgBN,EAAMxI,QAAOuJ,QACtBA,IAASA,EAAKb,UAAoB,QAEjCoB,EAAeP,EAAKb,GAAYmB,cAAcE,SAASH,GACvDI,EAAiBrB,GAAkBY,EAAKZ,IACvBY,EAAKZ,GAAgBkB,cAAcE,SAASH,UAC5DE,GAAgBE,CAAc,KAMzC7G,QAAQC,mBAAmB0F,EAAcxQ,yBAEzCwQ,UAIFC,GAAoB,mCAIpB5F,QAAQC,IAAI,qBACZyF,GAAe,aAOM1N,UACbA,EAAMxD,SACP,YACHwD,EAAM8O,iBACDpB,OAAcA,GAAe,OAClCE,EAAmBjQ,KAAKoR,IAAInB,EAAmB,EAAGD,EAAcxQ,OAAS,IACzE4Q,cAEG,UACH/N,EAAM8O,iBACDpB,OAAcA,GAAe,OAClCE,EAAmBjQ,KAAKC,IAAIgQ,EAAmB,GAAI,IACnDG,cAEG,QACCL,GAAgBE,GAAoB,GAAKA,EAAmBD,EAAcxQ,QAC5EgR,EAAiBR,EAAcC,cAG9B,SACHE,uBAsCJJ,GAAe,GAGXjR,GAASgR,IAAeY,EAAe5R,KACzCuL,QAAQC,IAAI,yCACZxL,EAAQ,MACRoR,EAAS,SAAU,uBAMrB7F,QAAQC,IAAI,4CACZxL,EAAQ,UACRgR,EAAa,QACbC,GAAe,OACfC,MAAoBN,IACpBQ,EAAS,SAAU,MAGfV,GACFA,EAAa6B,iDAwBF7B,0BACCM,uCAkBUU,EAAiBC,UACbR,EAAmBxJ,2CARdgJ,wTCuCD,IAAzB5J,KAAcrG,wQAGVqG,0BAALrG,4KAAKqG,aAALrG,uIAAAA,4NAUiCqG,MAAKsJ,uJAALtJ,MAAKsJ,uEAF/BtJ,MAAKjE,UACDiE,MAAKsJ,yQAPctJ,WAAQA,OAAqBA,MAAQ,cAAgB,iKAM5EA,MAAKjE,iBACDiE,MAAKsJ,kGAPctJ,WAAQA,OAAqBA,MAAQ,cAAgB,gHAVrEA,KAAe,IAAM,MAGtCA,uIANYA,+NAJDA,uFACFA,kBACAA,oBACEA,+CACCA,qBAJDA,UAAAA,mBAOMA,KAAe,IAAM,aAGtCA,+HArMIyL,GAAmBC,UACrBA,EACEA,EAAKpC,OAASoC,EAAK3P,SAAS2P,EAAKpC,OAASoC,EAAK3P,KADpC,0BARhB4N,EACAC,SAVOzC,qBACA2C,EAAc,wCACd6B,EAAe,QAGtB1B,EAAa,GACbC,GAAe,EACf0B,KACAxB,GAAoB,QAKlBC,EAAWxM,aAoERgO,EAAaH,GACpBlH,QAAQC,IAAI,iBAAkBiH,GAAM3P,MAE/B2P,SAELC,EAAeD,OACfzB,EAAawB,GAAmBC,IAGhCpB,IACAD,EAAS,SAAUqB,aAIZpB,QACPJ,GAAe,YA0CRK,OACHH,GAAoB,GAAKR,SACrBY,EAAgBZ,EAAgBa,4BAA4BL,KAC9DI,GACFA,EAAcE,gBAAiBrK,MAAO,sBAM5ByL,IACdtH,QAAQC,IAAI,gCACZkH,EAAe,UACf1B,EAAa,IACbI,EAAS,SAAU,UAGnBH,GAAe,GAGXP,GACFA,EAAa6B,iBAwBRV,EAAmBtO,GACtB0N,GAAgBP,IAAiBC,EAAgB3D,SAASzJ,EAAMpD,UAAYuQ,EAAa1D,SAASzJ,EAAMpD,SAC1GkR,IAKJ5M,QACE1B,SAASW,iBAAiB,QAASmO,QAEjC9O,SAASY,oBAAoB,QAASkO,gLA3KnCa,GAAgBA,EAAa5P,MAAQ4N,IAAiBA,EAAaoB,QAAQ,eAChFd,EAAawB,GAAmBE,wBAKhCnH,QAAQC,iBAAiB0C,EAAMxN,8BAA8BsQ,MAEzDA,GAAoC,KAAtBA,EAAWe,cACrBe,EAAS9B,EAAWiB,cAAcF,WAExCY,EAAgBzE,EAAM9F,QAAOqK,QAEtBA,IAASA,EAAK3P,YAAa,QAG1BiQ,EAAYN,EAAK3P,KAAKmP,cAAcE,SAASW,GAG7CE,EAAWP,EAAKpC,KAAOoC,EAAKpC,IAAI4B,cAAcE,SAASW,UAEtDC,GAAaC,CAAQ,KAI1BtC,GAAgBA,EAAaoB,QAAQ,eACvCb,GAAe,YAIjB0B,MAAoBzE,GAAO9I,MAAM,EAAG,UAItC+L,GAAoB,GAEpB5F,QAAQC,mBAAmBmH,EAAcjS,4CAKzC6K,QAAQC,IAAI,iBAAkBwF,OAC9BC,GAAe,GAGXyB,GAAgB1B,IAAewB,GAAmBE,KACpDnH,QAAQC,IAAI,6DACZkH,EAAe,MACftB,EAAS,SAAU,mBAMrB7F,QAAQC,IAAI,qBACZyF,GAAe,eAuBM1N,MAChB0N,SAEG1N,EAAMxD,SACP,YACHwD,EAAM8O,qBACNlB,EAAmBjQ,KAAKoR,IAAInB,EAAmB,EAAGwB,EAAcjS,OAAS,IACzE4Q,cAGG,UACH/N,EAAM8O,qBACNlB,EAAmBjQ,KAAKC,IAAIgQ,EAAmB,GAAI,IACnDG,cAGG,QACCH,GAAoB,GAAKA,EAAmBwB,EAAcjS,QAC5DkS,EAAaD,EAAcxB,cAI1B,SACHE,cAGG,YAECL,EAAWtQ,QAAU,GACvBuS,qBACEhC,GAAe,KACd,sBAkCT4B,IAGInC,IACFA,EAAa6B,QAGbU,qBACEhC,GAAe,OAGfD,EAAa,QACb2B,MAAoBzE,GAAO9I,MAAM,EAAG,QACnC,8CAwBQsL,0BACCM,uCAkBU4B,EAAaH,UACTtB,EAAmBxJ,2CARdgJ,4WC9KH5J,KAAS,IAAIjE,UAG9BiE,0BAALrG,isBA8BSqG,6TPsRrB,IAA0BjI,+DO3TqBiI,oCA+CCA,mBP4QtBjI,OACf,SAAUyE,GAGb,OAFAA,EAAM2P,kBAECpU,EAAGuG,KAAKE,KAAMhC,kBOnUIwD,oCAQCA,KAAS,IAAIjE,mCAG9BiE,aAALrG,+HAAAA,oBA8BSqG,gFApB6BA,MAAQuJ,iIAARvJ,MAAQuJ,4DAGVvJ,MAAQoM,gIAARpM,MAAQoM,2GAK1BpM,MAAQqM,qCAAgBrM,MAAQjE,oIAAhCiE,MAAQqM,qCAAgBrM,MAAQjE,yFAZnBiE,MAAQjE,UAEFiE,MAAQsJ,SAClCtJ,MAAQuJ,gBAGRvJ,MAAQoM,iBAIVpM,MAAQqM,oZAdMrM,KAAWA,OAAW,WAAa,4NAI3BA,MAAQjE,6BAEFiE,MAAQsJ,gBAClCtJ,MAAQuJ,8DAGRvJ,MAAQoM,kEAIVpM,MAAQqM,iGAdMrM,KAAWA,OAAW,WAAa,kHAdjEA,MAAaA,KAASrG,OAAS,0EAA/BqG,MAAaA,KAASrG,OAAS,sIA/BvB2S,mBACAC,GAAY,KAGnBC,EAAkB,WAEhBnC,EAAWxM,aAGR4O,EAAcL,OACrBI,EAAkBJ,GAClB/B,EAAS,SAAU+B,YAGZM,IACPrC,EAAS,kIAKLiC,GAAYA,EAAS3S,YACvB6S,EAAkB,6BAKFJ,UACXI,GAAmBA,EAAgBxI,KAAOoI,EAAQpI,qCAmB/ByI,EAAcL,QA6B5BI,IACFnC,EAAS,UAAWmC,GACpBE,oOCqUG1M,sBACYA,sBAAAA,sFACRA,qFAFJA,sCACYA,+0BAWLA,oFAAAA,gFAOXA,MAAWjE,MAASiE,MAAgBA,KAAajE,MAAS,cACrCiE,MAAWqJ,UAAarJ,MAAeA,KAAYjE,MAAS,iBACzDiE,MAAWsJ,KAAQtJ,MAAgBA,KAAasJ,KAAQ,iBAG/EtJ,MAAaA,KAAUuJ,QAAYvJ,MAAgBA,KAAauJ,0DAMhEvJ,MAAW2D,SAA2D,IAAhD1L,OAAOoL,KAAKrD,KAAU2D,aAAehK,siBAX5DqG,MAAWjE,MAASiE,MAAgBA,KAAajE,MAAS,iCACrCiE,MAAWqJ,UAAarJ,MAAeA,KAAYjE,MAAS,sCACzDiE,MAAWsJ,KAAQtJ,MAAgBA,KAAasJ,KAAQ,uBAG/EtJ,MAAaA,KAAUuJ,QAAYvJ,MAAgBA,KAAauJ,6LACtCvJ,MAAaA,KAAUuJ,QAAYvJ,MAAgBA,KAAauJ,QAAW,kJAA3EvJ,MAAaA,KAAUuJ,QAAYvJ,MAAgBA,KAAauJ,QAAW,8DAShGtR,OAAO0U,QAAQ3M,KAAU2D,kCAA9BhK,+MAAK1B,OAAO0U,QAAQ3M,KAAU2D,qBAA9BhK,+HAAAA,2PAEwBqG,WACA4M,GAAY5M,OAAO/G,aACjB+G,OAAOyJ,UAAY,4XAFrBzJ,8BACA4M,GAAY5M,OAAO/G,gCACjB+G,OAAOyJ,UAAY,4GA9BpDzJ,KAAY,aAAe,gDApCnBA,yFAIKA,eAAAA,sEACDA,yDAQPA,KAIIA,OAIsB,IAAtBA,KAAWrG,yCAkBlBqG,cAKc,OAAdA,WAAoChF,IAAdgF,MAAgD,iBAAdA,6CAmCnDA,gBACCA,uBACAA,uBACCA,qBACFA,skBAhDkCA,OAAcA,2UAAxCA,iDAnCPA,6BAIKA,gERujBhBG,EAAS,CACL0M,EAAG,EACHnM,EAAG,GACH9G,EAAGuG,iCAIFA,EAAO0M,GACR1U,EAAQgI,EAAOO,GAEnBP,EAASA,EAAOvG,iFQjiBboG,KAAY,aAAe,wCADcA,OAAcA,uBAIrDA,4DAKc,OAAdA,WAAoChF,IAAdgF,MAAgD,iBAAdA,8FAoClDA,wMA5aJ4M,GAAY3T,UACfA,QAA8C,OAC3C6T,WAAW7T,GAAO8T,QAAQ,YAkJ1BC,GAAkBrJ,OAEpBA,GAA8B,iBAAZA,iBAGjBsJ,SAGJhV,OAAO0U,QAAQhJ,GAAStL,WAAUmR,EAAQ0D,MAEpCA,UAGqB,iBAAdA,QACalS,IAApBkS,EAAUjU,OACU,OAApBiU,EAAUjU,OACV6T,WAAWI,EAAUjU,OAAS,EAEhCgU,EAAgBzD,GAAU0D,EACI,iBAAdA,GAA0BA,EAAY,EAEtDD,EAAgBzD,IAAYvQ,MAAOiU,EAAWzD,SAAU,OAC1B,iBAAdyD,GAA0BJ,WAAWI,GAAa,IAElED,EAAgBzD,IAAYvQ,MAAO6T,WAAWI,GAAYzD,SAAU,kBAGjE0D,UACP3I,QAAQS,MAAM,0BAA2BkI,aAIpCF,yBAxMLG,EAEAC,EAAc,KACdlE,EAAW,GACXmE,EAAY,KACZC,GAAY,EACZtI,EAAQ,KACRuI,KAGAC,KACAC,GAAiB,EACjB/B,EAAe,KAIfgC,GAAsB,EACtBnB,EAAkB,YA4StB9O,iBAEI8G,QAAQC,IAAI,kDAENb,QAAa4E,GAAgBzB,aACnCvC,QAAQC,cAAcb,EAAKjK,qBAGrBiU,EAAiBhK,EAAKvC,QAAOwC,IAAQA,EAAIG,QAC3C4J,EAAejU,OAAS,GAC1B6K,QAAQyD,cAAc2F,EAAejU,+BAEjCkU,EAAQ1T,KAAKC,OAAOwJ,EAAKvC,QAAOwC,GAAOA,EAAIG,KAAI5C,KAAIyC,GAAOA,EAAIG,KAAK,GACvE4J,EAAevV,SAAQwL,IACrBgK,IACAhK,EAAIG,GAAK6J,CAAK,IAEhBrJ,QAAQC,IAAI,kDAIRqJ,EAAmBlK,EAAKvC,QAAOwC,IAAQA,EAAIkK,OAC7CD,EAAiBnU,OAAS,GAC5B6K,QAAQyD,cAAc6F,EAAiBnU,iCAGzC6T,EAAgB5J,SACTqB,GACPT,QAAQS,MAAM,0BAA2BA,GAEzCT,QAAQC,IAAI,yCACJ6B,gBAAyB,6BACjCkH,EAAgBlH,GAIlB9B,QAAQC,uBAAuB+I,EAAc7T,UACzC6T,EAAc7T,OAAS,GACzB6K,QAAQC,IAAI,kBAAmB+I,EAAcnP,MAAM,EAAG,8CAzU3B7B,OAC7B6Q,EAAc7Q,EAAMuB,QACpByG,QAAQC,IAAI,gBAAiB4I,GAEzBA,GAAeA,EAAYrJ,kBASFH,OACxBA,aACAA,EAAIG,UACPQ,QAAQS,MAAM,wCAAyCpB,YACvDoB,EAAQ,kDAMRqI,EAAY,UACZ3B,EAAe,MACfxC,EAAW,OACXsE,UAGAC,GAAiB,OACjBzI,EAAQ,MAERT,QAAQC,6BAA6BZ,EAAI9H,eAAe8H,EAAIkK,aAAalK,EAAIG,cAGzEmD,QAAcqB,GAAgBnB,eAAexD,EAAIkK,KAAMlK,EAAIG,OAG1DmD,GAA0B,IAAjBA,EAAMxN,SAClB6K,QAAQC,0CAA0CZ,EAAIkK,8BAGrC,QAAblK,EAAIkK,MACNvJ,QAAQC,IAAI,gDACZ0C,EAAQ6G,2BAGRxJ,QAAQC,sCAAsCZ,EAAIkK,QAClD5G,EAAQ3E,MAAMC,MAAO9I,OAAQ,MAAOsU,EAAGnU,MACrCkK,YAAaH,EAAIkK,QAAQjU,EAAE,IAC3BiC,QAAS8H,EAAI9H,aAAajC,EAAE,IAC5BwP,OAAQxP,EAAE,QACVoU,SAAUrK,EAAIkK,KACd1E,SAAUxF,EAAI9H,WAKpByI,QAAQC,gBAAgB0C,EAAQA,EAAMxN,OAAS,2BAE1CwN,GAA0B,IAAjBA,EAAMxN,cAClB6K,QAAQC,IAAI,2CACZiJ,GAAiB,SAKbS,EAAahH,EAAM,GACzB3C,QAAQC,IAAI,yBAA0B0J,GAEtC3J,QAAQC,gBAAgB0C,EAAMxN,wBAAwBkK,EAAI9H,YAG1D0R,EAAatG,EAAM/F,KAAIsK,KACrB1H,GAAI0H,EAAK1H,gBAAkB0H,EAAKpC,KAAOnP,KAAKiU,WAC5CrS,KAAM2P,EAAK3P,MAAQ,eACnBuN,IAAKoC,EAAKpC,KAAO,GACjBC,OAAQmC,EAAKnC,QAAU,GACvB6C,QAASV,EAAKU,SAAW,GACzBC,UAAWX,EAAKW,WAAa,QAG/B7H,QAAQC,mBAAmBgJ,EAAW9T,kCAGhC0U,EAAelH,EAAM9F,QAAOqK,IAASA,EAAK3P,OAC5CsS,EAAa1U,OAAS,IACxB6K,QAAQyD,cAAcoG,EAAa1U,+BACnC6K,QAAQyD,KAAK,uBAAwBoG,EAAa,SAGpDX,GAAiB,OAEjBA,GAAiB,SACVP,GACP3I,QAAQS,MAAM,+BAAgCkI,OAC9CO,GAAiB,OACjBD,OA5FAa,CAAgBjB,IAEhB7I,QAAQS,MAAM,6CAA8CoI,OAC5DpI,EAAQ,+DA8FczI,GACxBgI,QAAQC,IAAI,wBAAyBjI,EAAMuB,YAG3CuP,EAAY,UAGZ3B,EAAenP,EAAMuB,QACrBoL,EAAWwC,EAAeA,EAAa5P,KAAO,OAG9CkJ,EAAQ,MAGJ0G,IAAiBA,EAAa3H,KAChCQ,QAAQS,MAAM,8CAA+C0G,OAC7D1G,EAAQ,iEAKiBzI,GAC3BgQ,EAAkBhQ,EAAMuB,iBAGIvB,GAC5BgQ,EAAkBhQ,EAAMuB,sBAkDWqO,WAE5BA,IAAYA,EAAQpI,aACbvG,MAAM,4BAGlB8P,GAAY,OACZtI,EAAQ,YAGFsJ,QAAqB/F,GAAgBf,eAAe2E,EAAQpI,IAG9DuK,GAAgBA,EAAa5K,UAC/B4K,EAAa5K,QAAUqJ,GAAkBuB,EAAa5K,cAGxD2J,EAAYiB,OACZhB,GAAY,SACLJ,GACP3I,QAAQS,MAAM,qCAAsCkI,OACpDlI,EAAQkI,EAAIqB,aACZjB,GAAY,OAIV/I,QAAQC,IAAI,qDACN2E,QAAiBZ,GAAgBS,aAAaoE,EAAYtR,KAAMoN,GAGlEC,GAAYA,EAASzF,UACvByF,EAASzF,QAAUqJ,GAAkB5D,EAASzF,UAG5CyI,IAEFhD,EAASrN,KAAOqQ,EAAQrQ,KACxBqN,EAASE,IAAM8C,EAAQ9C,IACnB8C,EAAQ7C,SACVH,EAASG,OAAS6C,EAAQ7C,aAI9B+D,EAAYlE,OACZnE,EAAQ,qFACDwJ,GACPjK,QAAQS,MAAM,4BAA6BwJ,KA/F/CC,CAAsBlC,mBAItBmB,GAAsB,wBAiGjBN,KAKA1B,OAKL4B,GAAY,OACZtI,EAAQ,gBAIAsC,EA3GDoE,EAAeA,EAAa3H,GAAK,SA4GjCuD,YACO9J,MAAM,uCAGlB+G,QAAQC,wCAAwC8C,WAG1CgH,QAAqB/F,GAAgBf,eAAeF,GAE1D/C,QAAQC,IAAI,uBAAwB8J,GAGhCA,GAAgBA,EAAa5K,SAC/B4K,EAAa5K,QAAUqJ,GAAkBuB,EAAa5K,SACtDa,QAAQC,IAAI,yBAA0B8J,EAAa5K,UAEnDa,QAAQyD,KAAK,yCAA0CsG,OAGzDjB,EAAYiB,SAELpB,GACP3I,QAAQS,MAAM,aAAckI,OAC5BlI,EAAQkI,EAAIqB,aAIVhK,QAAQC,IAAI,yCACN2E,QAAiBZ,GAAgBS,aAAaoE,EAAYtR,KAAMoN,GAGlEC,GAAYA,EAASzF,UACvByF,EAASzF,QAAUqJ,GAAkB5D,EAASzF,cAGhD2J,EAAYlE,OACZnE,EAAQ,qFACDwJ,GACPjK,QAAQS,MAAM,4BAA6BwJ,gBAG7ClB,GAAY,aAnDZtI,EAAQ,iCALRA,EAAQ,oCAmHMoI,oDAuBCD,2BAEQzB,aCrZxB,MAACgD,GAAM,kEAAQ,CAClBvV,OAAQ4C,SAAS4S"}